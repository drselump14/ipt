# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::Disallowed
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end

  def disallowed_behavior(); end

  def disallowed_behavior=(behavior); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def hash(*_, &_1); end

  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end

  def instance_methods(*_, &_1); end

  def name(*_, &_1); end

  def respond_to?(*_, &_1); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, **options, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::Disallowed
  def disallowed_warnings(); end

  def disallowed_warnings=(disallowed_warnings); end
end

module ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def allow(allowed_warnings=T.unsafe(nil), if: T.unsafe(nil), &block); end

  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(&block); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.allow(*_, &_1); end

  def self.behavior(*_, &_1); end

  def self.behavior=(arg); end

  def self.debug(*_, &_1); end

  def self.debug=(arg); end

  def self.deprecate_methods(*_, &_1); end

  def self.deprecation_horizon(*_, &_1); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*_, &_1); end

  def self.disallowed_behavior(*_, &_1); end

  def self.disallowed_behavior=(arg); end

  def self.disallowed_warnings(*_, &_1); end

  def self.disallowed_warnings=(arg); end

  def self.gem_name(*_, &_1); end

  def self.gem_name=(arg); end

  def self.initialize(*_, &_1); end

  def self.silence(*_, &_1); end

  def self.silenced(*_, &_1); end

  def self.silenced=(arg); end

  def self.warn(*_, &_1); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(*hashes, &block); end

  def merge!(*other_hashes, &block); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(*other_hashes, &block); end

  def values_at(*keys); end

  def without(*keys); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*_, &_1); end

  def acts_like_string?(*_, &_1); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*_, &_1); end

  def method_missing(method, *args, &block); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(_); end

  def tidy_bytes(string, force=T.unsafe(nil)); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def allocations(); end

  def children(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def finish!(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def payload=(payload); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(*_); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def pattern(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end

  def self.wrap_all(pattern, subscriber); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.monotonic_subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.subscribed(callback, pattern=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def self.unsubscribe(subscriber_or_name); end
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(*args); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def match?(re); end

  def name(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.clear(); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(method_name=T.unsafe(nil), *args, &b); end

  def try!(method_name=T.unsafe(nil), *args, &b); end
end

module ActiveSupport::Tryable
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  def self.escape_html_entities_in_json(*_, &_1); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*_, &_1); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.time_precision(*_, &_1); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*_, &_1); end

  def self.use_standard_json_time_format=(arg); end
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Anyway
  VERSION = ::T.let(nil, ::T.untyped)
end

module Anyway::AutoCast
  ARRAY_RXP = ::T.let(nil, ::T.untyped)
end

module Anyway::AutoCast
  def self.call(val); end
end

class Anyway::Config
  include ::Anyway::OptparseConfig
  include ::Anyway::DynamicConfig
  def clear(); end

  def config_name(); end

  def deconstruct_keys(keys); end

  def dig(*keys); end

  def env_prefix(); end

  def initialize(overrides=T.unsafe(nil)); end

  def load(overrides=T.unsafe(nil)); end

  def load_from_sources(base_config, **options); end

  def reload(overrides=T.unsafe(nil)); end

  def resolve_config_path(name, env_prefix); end

  def to_h(); end

  def to_source_trace(); end
  PARAM_NAME = ::T.let(nil, ::T.untyped)
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

class Anyway::Config::BlockCallback
  def apply_to(config); end

  def block(); end

  def initialize(block); end
end

class Anyway::Config::BlockCallback
end

class Anyway::Config::Error
end

class Anyway::Config::Error
end

class Anyway::Config::NamedCallback
  def apply_to(config); end

  def initialize(name); end

  def name(); end
end

class Anyway::Config::NamedCallback
end

class Anyway::Config::ValidationError
end

class Anyway::Config::ValidationError
end

class Anyway::Config
  extend ::Anyway::OptparseConfig::ClassMethods
  extend ::Anyway::DynamicConfig::ClassMethods
  def self.attr_config(*args, **hargs); end

  def self.config_attributes(); end

  def self.config_name(val=T.unsafe(nil)); end

  def self.defaults(); end

  def self.env_prefix(val=T.unsafe(nil)); end

  def self.explicit_config_name(); end

  def self.explicit_config_name?(); end

  def self.load_callbacks(); end

  def self.new_empty_config(); end

  def self.on_load(*names, &block); end

  def self.required(*names); end

  def self.required_attributes(); end
end

module Anyway::DynamicConfig
end

module Anyway::DynamicConfig::ClassMethods
  def for(name, **options); end
end

module Anyway::DynamicConfig::ClassMethods
end

module Anyway::DynamicConfig
  def self.included(base); end
end

class Anyway::Env
  include ::Anyway::Tracing
  def clear(); end

  def data(); end

  def fetch(prefix); end

  def fetch_with_trace(prefix); end

  def initialize(type_cast: T.unsafe(nil)); end

  def traces(); end

  def type_cast(); end
end

class Anyway::Env
end

module Anyway::Ext
end

module Anyway::Ext::DeepDup
end

module Anyway::Ext::DeepDup
end

module Anyway::Ext::DeepFreeze
end

module Anyway::Ext::DeepFreeze
end

module Anyway::Ext::Hash
end

module Anyway::Ext::Hash
end

module Anyway::Ext
end

module Anyway::Loaders
end

class Anyway::Loaders::Base
  include ::Anyway::Tracing
  def initialize(local:); end

  def use_local?(); end
end

class Anyway::Loaders::Base
  def self.call(local: T.unsafe(nil), **opts); end
end

class Anyway::Loaders::Env
  def call(env_prefix:, **_options); end
end

class Anyway::Loaders::Env
end

class Anyway::Loaders::Registry
  def append(id, handler=T.unsafe(nil), &block); end

  def delete(id); end

  def each(&block); end

  def insert_after(another_id, id, handler=T.unsafe(nil), &block); end

  def insert_before(another_id, id, handler=T.unsafe(nil), &block); end

  def override(id, handler); end

  def prepend(id, handler=T.unsafe(nil), &block); end

  def registry(); end
end

class Anyway::Loaders::Registry
end

class Anyway::Loaders::YAML
  def call(config_path:, **_options); end
end

class Anyway::Loaders::YAML
end

module Anyway::Loaders
end

class Anyway::OptionParserBuilder
end

class Anyway::OptionParserBuilder
  def self.call(options); end
end

module Anyway::OptparseConfig
  def option_parser(); end

  def parse_options!(options); end
end

module Anyway::OptparseConfig::ClassMethods
  def describe_options(**hargs); end

  def extend_options(&block); end

  def flag_options(*args); end

  def ignore_options(*args); end

  def option_parser_descriptors(); end

  def option_parser_extensions(); end

  def option_parser_options(); end
end

module Anyway::OptparseConfig::ClassMethods
end

module Anyway::OptparseConfig
  def self.included(base); end
end

class Anyway::Settings
end

class Anyway::Settings::Future
  def use(*names); end
end

class Anyway::Settings::Future
  def self.setting(name, default_value); end

  def self.settings(); end
end

class Anyway::Settings
  def self.default_config_path(); end

  def self.default_config_path=(val); end

  def self.future(); end

  def self.tracing_enabled(); end

  def self.tracing_enabled=(tracing_enabled); end

  def self.use_local_files(); end

  def self.use_local_files=(use_local_files); end
end

module Anyway::Tracing
end

class Anyway::Tracing::Trace
  def clear(); end

  def dig(*_, &_1); end

  def initialize(type=T.unsafe(nil), value=T.unsafe(nil), **source); end

  def keep_if(*_, &_1); end

  def merge!(another_trace); end

  def merge_values(hash, **opts); end

  def record_value(val, *path, **opts); end

  def source(); end

  def to_h(); end

  def trace?(); end

  def type(); end

  def value(); end
  UNDEF = ::T.let(nil, ::T.untyped)
end

class Anyway::Tracing::Trace
end

module Anyway::Tracing
  def self.capture(); end

  def self.current_trace(); end

  def self.current_trace_source(); end

  def self.source_stack(); end

  def self.trace!(type, *path, **opts); end

  def self.trace_stack(); end

  def self.tracing?(); end

  def self.with_trace_source(src); end
end

module Anyway::Utils
end

module Anyway::Utils
  def self.deep_merge!(source, other); end
end

module Anyway
  def self.env(); end

  def self.loaders(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def deconstruct(); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

module Aruba
  PLATFORM_MUTEX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Aruba::ArubaPath
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Aruba::BasicConfiguration
  extend ::Contracts
  extend ::Contracts::Attrs
  extend ::Contracts::Builtin
  extend ::Contracts::Core
end

class Aruba::Command
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Aruba::Matchers::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Aruba::Matchers::ObjectFormatter
  DATE_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

Aruba::Platform = Aruba::Platforms::UnixPlatform

class Aruba::Platforms::FilesystemStatus
  METHODS = ::T.let(nil, ::T.untyped)
end

class Aruba::Platforms::UnixCommandString
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Aruba::Platforms::UnixEnvironmentVariables
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Aruba::Platforms::WindowsCommandString
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::Definition
  def dependencies_for(groups); end

  def disable_multisource?(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Dsl
  def check_primary_source_safety(); end
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end
end

class Bundler::Resolver::SpecGroup
  def activate_all_platforms!(); end

  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def partitioned_dependency_names_for_activated_platforms(); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source
  def cached!(); end

  def local!(); end

  def remote!(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def disable_multisource?(); end
end

class Bundler::SourceList
  def disable_multisource?(); end

  def global_path_source(); end

  def merged_gem_lockfile_sections!(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::StubSpecification
  def default_gem?(); end

  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::HTML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

module CodeRay::Encoders::HTML::Output
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Java
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Scanner
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Contract
  DEFAULT_FAILURE_CALLBACK = ::T.let(nil, ::T.untyped)
end

module Contracts::Builtin
  ArrayOf = ::T.let(nil, ::T.untyped)
  SetOf = ::T.let(nil, ::T.untyped)
end

class Contracts::ContractsNotIncluded
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Contracts::MethodHandler
  METHOD_REFERENCE_FACTORY = ::T.let(nil, ::T.untyped)
  RAW_METHOD_STRATEGY = ::T.let(nil, ::T.untyped)
end

module Contracts::Validators
  DEFAULT_VALIDATOR_STRATEGIES = ::T.let(nil, ::T.untyped)
end

module Cucumber
  BINARY = ::T.let(nil, ::T.untyped)
  IRONRUBY = ::T.let(nil, ::T.untyped)
  JRUBY = ::T.let(nil, ::T.untyped)
  LIBDIR = ::T.let(nil, ::T.untyped)
  OS_X = ::T.let(nil, ::T.untyped)
  RAILS = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  RUBY_1_9 = ::T.let(nil, ::T.untyped)
  RUBY_2_0 = ::T.let(nil, ::T.untyped)
  RUBY_BINARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
  WINDOWS_MRI = ::T.let(nil, ::T.untyped)
end

class Cucumber::Ambiguous
  def initialize(step_name, step_definitions, used_guess); end
end

class Cucumber::Ambiguous
end

class Cucumber::AmbiguousStepMatch
  def activate(test_step); end

  def initialize(error); end
end

class Cucumber::AmbiguousStepMatch
end

class Cucumber::Cli::Configuration
  include ::Cucumber::Constantize
end

class Cucumber::Cli::Options
  BUILTIN_FORMATS = ::T.let(nil, ::T.untyped)
  CUCUMBER_PUBLISH_URL = ::T.let(nil, ::T.untyped)
  FAIL_FAST_FLAG = ::T.let(nil, ::T.untyped)
  FORMAT_HELP = ::T.let(nil, ::T.untyped)
  FORMAT_HELP_MSG = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  NO_PROFILE_LONG_FLAG = ::T.let(nil, ::T.untyped)
  NO_PROFILE_SHORT_FLAG = ::T.let(nil, ::T.untyped)
  OPTIONS_WITH_ARGS = ::T.let(nil, ::T.untyped)
  ORDER_TYPES = ::T.let(nil, ::T.untyped)
  PROFILE_LONG_FLAG = ::T.let(nil, ::T.untyped)
  PROFILE_SHORT_FLAG = ::T.let(nil, ::T.untyped)
  RETRY_FLAG = ::T.let(nil, ::T.untyped)
  TAG_LIMIT_MATCHER = ::T.let(nil, ::T.untyped)
end

class Cucumber::Cli::ProfileLoader
  def args_from(profile); end

  def cucumber_yml_defined?(); end

  def profile?(profile); end
end

class Cucumber::Cli::ProfileLoader
end

class Cucumber::Cli::RerunFile
  def features(); end

  def initialize(path); end

  def path(); end
end

class Cucumber::Cli::RerunFile
  def self.can_read?(path); end

  def self.real_path(path); end
end

class Cucumber::Configuration
  include ::Cucumber::Constantize
  def all_files_to_load(); end

  def autoload_code_paths(); end

  def custom_profiles(); end

  def dry_run?(); end

  def duration?(); end

  def error_stream(); end

  def event_bus(); end

  def expand?(); end

  def fail_fast?(); end

  def feature_dirs(); end

  def feature_files(); end

  def filters(); end

  def formats(); end

  def formatter_class(format); end

  def formatter_factories(); end

  def guess?(); end

  def id_generator(); end

  def initialize(user_options=T.unsafe(nil)); end

  def name_regexps(); end

  def notify(message, *args); end

  def on_event(*args, &block); end

  def out_stream(); end

  def paths(); end

  def profiles(); end

  def publish_enabled?(); end

  def publish_quiet?(); end

  def randomize?(); end

  def register_snippet_generator(generator); end

  def retry_attempts(); end

  def seed(); end

  def skip_profile_information?(); end

  def snippet_generators(); end

  def snippet_type(); end

  def snippets?(); end

  def source?(); end

  def step_defs_to_load(); end

  def strict(); end

  def support_to_load(); end

  def tag_expressions(); end

  def tag_limits(); end

  def to_hash(); end

  def wip?(); end

  def with_options(new_options); end
end

class Cucumber::Configuration
  extend ::Forwardable
  def self.default(); end
end

module Cucumber::Constantize
  def constantize(camel_cased_word); end

  def underscore(camel_cased_word); end
end

module Cucumber::Constantize
end

class Cucumber::Core::Test::DocString
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Cucumber::Core::Test::Result
  STRICT_AFFECTED_TYPES = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

module Cucumber::CreateMeta
  CI_DICT = ::T.let(nil, ::T.untyped)
end

module Cucumber::CucumberExpressions
  ALTERNATION_CHARACTER = ::T.let(nil, ::T.untyped)
  BEGIN_OPTIONAL_CHARACTER = ::T.let(nil, ::T.untyped)
  BEGIN_PARAMETER_CHARACTER = ::T.let(nil, ::T.untyped)
  END_OPTIONAL_CHARACTER = ::T.let(nil, ::T.untyped)
  END_PARAMETER_CHARACTER = ::T.let(nil, ::T.untyped)
  ESCAPE_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::CombinatorialGeneratedExpressionFactory
  MAX_EXPRESSIONS = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::CucumberExpression
  ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Cucumber::CucumberExpressions::NodeType
  ALTERNATION = ::T.let(nil, ::T.untyped)
  ALTERNATIVE = ::T.let(nil, ::T.untyped)
  EXPRESSION = ::T.let(nil, ::T.untyped)
  OPTIONAL = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::ParameterType
  ILLEGAL_PARAMETER_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  UNESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::ParameterTypeRegistry
  ANONYMOUS_REGEXP = ::T.let(nil, ::T.untyped)
  FLOAT_REGEXP = ::T.let(nil, ::T.untyped)
  INTEGER_REGEXPS = ::T.let(nil, ::T.untyped)
  STRING_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Cucumber::CucumberExpressions::TokenType
  ALTERNATION = ::T.let(nil, ::T.untyped)
  BEGIN_OPTIONAL = ::T.let(nil, ::T.untyped)
  BEGIN_PARAMETER = ::T.let(nil, ::T.untyped)
  END_OF_LINE = ::T.let(nil, ::T.untyped)
  END_OPTIONAL = ::T.let(nil, ::T.untyped)
  END_PARAMETER = ::T.let(nil, ::T.untyped)
  START_OF_LINE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WHITE_SPACE = ::T.let(nil, ::T.untyped)
end

module Cucumber::Deprecate
end

class Cucumber::Deprecate::AnsiString
  include ::Cucumber::Gherkin::Formatter::AnsiEscapes
  def failure_message(message); end
end

class Cucumber::Deprecate::AnsiString
  def self.failure_message(message); end
end

class Cucumber::Deprecate::CliOption
end

class Cucumber::Deprecate::CliOption
  def self.deprecate(stream, option, message, remove_after_version); end
end

module Cucumber::Deprecate::ForDevelopers
end

module Cucumber::Deprecate::ForDevelopers
  def self.call(_message, _method, remove_after_version); end
end

module Cucumber::Deprecate::ForUsers
end

module Cucumber::Deprecate::ForUsers
  def self.call(message, method, remove_after_version); end
end

Cucumber::Deprecate::STRATEGY = Cucumber::Deprecate::ForUsers

module Cucumber::Deprecate
end

module Cucumber::Events
end

class Cucumber::Events::Envelope
end

class Cucumber::Events::Envelope
end

class Cucumber::Events::GherkinSourceParsed
end

class Cucumber::Events::GherkinSourceParsed
end

class Cucumber::Events::GherkinSourceRead
end

class Cucumber::Events::GherkinSourceRead
end

class Cucumber::Events::HookTestStepCreated
end

class Cucumber::Events::HookTestStepCreated
end

class Cucumber::Events::StepActivated
  def initialize(test_step, step_match); end
end

class Cucumber::Events::StepActivated
end

class Cucumber::Events::StepDefinitionRegistered
  def initialize(step_definition); end
end

class Cucumber::Events::StepDefinitionRegistered
end

class Cucumber::Events::TestCaseCreated
end

class Cucumber::Events::TestCaseCreated
end

class Cucumber::Events::TestCaseFinished
end

class Cucumber::Events::TestCaseFinished
end

class Cucumber::Events::TestCaseReady
end

class Cucumber::Events::TestCaseReady
end

class Cucumber::Events::TestCaseStarted
end

class Cucumber::Events::TestCaseStarted
end

class Cucumber::Events::TestRunFinished
end

class Cucumber::Events::TestRunFinished
end

class Cucumber::Events::TestRunStarted
end

class Cucumber::Events::TestRunStarted
end

class Cucumber::Events::TestStepCreated
end

class Cucumber::Events::TestStepCreated
end

class Cucumber::Events::TestStepFinished
end

class Cucumber::Events::TestStepFinished
end

class Cucumber::Events::TestStepStarted
end

class Cucumber::Events::TestStepStarted
end

class Cucumber::Events::UndefinedParameterType
end

class Cucumber::Events::UndefinedParameterType
end

module Cucumber::Events
  def self.make_event_bus(); end

  def self.registry(); end
end

class Cucumber::FileSpecs
  def files(); end

  def initialize(file_specs); end

  def locations(); end
  FILE_COLON_LINE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::FileSpecs::FileSpec
  def file(); end

  def initialize(spec); end

  def locations(); end
end

class Cucumber::FileSpecs::FileSpec
end

class Cucumber::FileSpecs
end

module Cucumber::Filters
end

class Cucumber::Filters::ActivateSteps
end

class Cucumber::Filters::ActivateSteps::CaseFilter
  def initialize(test_case, step_match_search, configuration); end

  def test_case(); end
end

class Cucumber::Filters::ActivateSteps::CaseFilter::FindMatch
  def initialize(step_match_search, configuration, test_step); end

  def result(); end
end

class Cucumber::Filters::ActivateSteps::CaseFilter::FindMatch
end

class Cucumber::Filters::ActivateSteps::CaseFilter
end

class Cucumber::Filters::ActivateSteps
end

class Cucumber::Filters::ApplyAfterHooks
end

class Cucumber::Filters::ApplyAfterHooks
end

class Cucumber::Filters::ApplyAfterStepHooks
end

class Cucumber::Filters::ApplyAfterStepHooks
end

class Cucumber::Filters::ApplyAroundHooks
end

class Cucumber::Filters::ApplyAroundHooks
end

class Cucumber::Filters::ApplyBeforeHooks
end

class Cucumber::Filters::ApplyBeforeHooks
end

class Cucumber::Filters::BroadcastTestCaseReadyEvent
end

class Cucumber::Filters::BroadcastTestCaseReadyEvent
end

class Cucumber::Filters::BroadcastTestRunStartedEvent
  def initialize(config, receiver=T.unsafe(nil)); end
end

class Cucumber::Filters::BroadcastTestRunStartedEvent
end

class Cucumber::Filters::GatedReceiver
  def done(); end

  def initialize(receiver); end

  def test_case(test_case); end
end

class Cucumber::Filters::GatedReceiver
end

class Cucumber::Filters::PrepareWorld
end

class Cucumber::Filters::PrepareWorld::CaseFilter
  def initialize(runtime, original_test_case); end

  def test_case(); end
end

class Cucumber::Filters::PrepareWorld::CaseFilter
end

class Cucumber::Filters::PrepareWorld
end

class Cucumber::Filters::Quit
  def done(); end

  def initialize(receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::Quit
end

class Cucumber::Filters::Randomizer
  def done(); end

  def initialize(seed, receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::Randomizer
end

class Cucumber::Filters::Retry
end

class Cucumber::Filters::Retry
end

class Cucumber::Filters::TagLimitExceededError
  def initialize(*limit_breaches); end
end

class Cucumber::Filters::TagLimitExceededError
end

class Cucumber::Filters::TagLimits
  def done(); end

  def initialize(tag_limits, receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::TagLimits::TestCaseIndex
  def add(test_case); end

  def count_by_tag_name(tag_name); end

  def locations_of_tag_name(tag_name); end
end

class Cucumber::Filters::TagLimits::TestCaseIndex
end

class Cucumber::Filters::TagLimits::Verifier
  def initialize(tag_limits); end

  def verify!(test_case_index); end
end

class Cucumber::Filters::TagLimits::Verifier::Breach
  def initialize(tag_name, limit, locations); end
  INDENT = ::T.let(nil, ::T.untyped)
end

class Cucumber::Filters::TagLimits::Verifier::Breach
end

class Cucumber::Filters::TagLimits::Verifier
end

class Cucumber::Filters::TagLimits
end

module Cucumber::Filters
end

module Cucumber::Formatter::ANSIColor
  include ::Cucumber::Term::ANSIColor
  def comment(string=T.unsafe(nil), &proc); end

  def comment_param(string=T.unsafe(nil), &proc); end

  def cukes(n); end

  def failed(string=T.unsafe(nil), &proc); end

  def failed_param(string=T.unsafe(nil), &proc); end

  def flaky(string=T.unsafe(nil), &proc); end

  def flaky_param(string=T.unsafe(nil), &proc); end

  def green_cukes(n); end

  def grey(string); end

  def outline(string=T.unsafe(nil), &proc); end

  def outline_param(string=T.unsafe(nil), &proc); end

  def passed(string=T.unsafe(nil), &proc); end

  def passed_param(string=T.unsafe(nil), &proc); end

  def pending(string=T.unsafe(nil), &proc); end

  def pending_param(string=T.unsafe(nil), &proc); end

  def red_cukes(n); end

  def skipped(string=T.unsafe(nil), &proc); end

  def skipped_param(string=T.unsafe(nil), &proc); end

  def tag(string=T.unsafe(nil), &proc); end

  def tag_param(string=T.unsafe(nil), &proc); end

  def undefined(string=T.unsafe(nil), &proc); end

  def undefined_param(string=T.unsafe(nil), &proc); end

  def yellow_cukes(n); end
  ALIASES = ::T.let(nil, ::T.untyped)
end

module Cucumber::Formatter::ANSIColor
  def self.define_grey(); end

  def self.define_real_grey(); end
end

module Cucumber::Formatter::Console
  include ::Cucumber::Formatter::Duration
  FORMATS = ::T.let(nil, ::T.untyped)
end

module Cucumber::Formatter::Console
  extend ::Cucumber::Formatter::ANSIColor
  extend ::Cucumber::Term::ANSIColor
end

class Cucumber::Formatter::CurlOptionParser
end

class Cucumber::Formatter::CurlOptionParser
  def self.parse(options); end

  def self.parse_header(header_arg); end

  def self.remove_arg_for(args, arg); end
end

module Cucumber::Formatter::Duration
  def format_duration(seconds); end
end

module Cucumber::Formatter::Duration
end

class Cucumber::Formatter::Fanout
  def initialize(recipients); end

  def method_missing(message, *args); end
end

class Cucumber::Formatter::Fanout
end

class Cucumber::Formatter::HTTPIO
end

class Cucumber::Formatter::HTTPIO
  def self.open(url, https_verify_mode=T.unsafe(nil), reporter=T.unsafe(nil)); end
end

class Cucumber::Formatter::IOHTTPBuffer
  def close(); end

  def closed?(); end

  def flush(); end

  def headers(); end

  def initialize(uri, method, headers=T.unsafe(nil), https_verify_mode=T.unsafe(nil), reporter=T.unsafe(nil)); end

  def method(); end

  def uri(); end

  def write(data); end
end

class Cucumber::Formatter::IOHTTPBuffer
end

class Cucumber::Formatter::IgnoreMissingMessages
  def initialize(receiver); end

  def method_missing(message, *args); end
end

class Cucumber::Formatter::IgnoreMissingMessages
end

class Cucumber::Formatter::NoReporter
  def report(banner); end
end

class Cucumber::Formatter::NoReporter
end

class Cucumber::Formatter::URLReporter
  def initialize(io); end

  def report(banner); end
end

class Cucumber::Formatter::URLReporter
end

module Cucumber::Gherkin
end

class Cucumber::Gherkin::DataTableParser
  def feature_header(); end

  def gherkin_options(); end

  def initialize(builder); end

  def parse(text); end
end

class Cucumber::Gherkin::DataTableParser
end

module Cucumber::Gherkin::Formatter
end

module Cucumber::Gherkin::Formatter::AnsiEscapes
  def comments(); end

  def comments_arg(); end

  def executing(); end

  def executing_arg(); end

  def failed(); end

  def failed_arg(); end

  def outline(); end

  def outline_arg(); end

  def passed(); end

  def passed_arg(); end

  def pending(); end

  def pending_arg(); end

  def reset(); end

  def skipped(); end

  def skipped_arg(); end

  def tag(); end

  def tag_arg(); end

  def undefined(); end

  def undefined_arg(); end

  def up(n); end
  ALIASES = ::T.let(nil, ::T.untyped)
  COLORS = ::T.let(nil, ::T.untyped)
end

module Cucumber::Gherkin::Formatter::AnsiEscapes
end

module Cucumber::Gherkin::Formatter::Escaping
  def escape_cell(sym); end
end

module Cucumber::Gherkin::Formatter::Escaping
end

module Cucumber::Gherkin::Formatter
end

module Cucumber::Gherkin::I18n
end

module Cucumber::Gherkin::I18n
  def self.code_keyword_for(gherkin_keyword); end

  def self.code_keywords_for(gherkin_keywords); end
end

class Cucumber::Gherkin::StepsParser
  def feature_header(dialect); end

  def gherkin_options(); end

  def initialize(builder, language); end

  def parse(text); end
end

class Cucumber::Gherkin::StepsParser
end

module Cucumber::Gherkin
end

module Cucumber::Glue::Dsl
  def A(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def AN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aber(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ac(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Adott(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def After(*tag_expressions, &proc); end

  def AfterConfiguration(&proc); end

  def AfterStep(*tag_expressions, &proc); end

  def Agus(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Akkor(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Alavez(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ale(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aleshores(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ali(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Allora(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Alors(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Als(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ama(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amennyiben(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amikor(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amma(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ampak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def An(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ananging(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ancaq(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def And(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Angenommen(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Anrhegediga(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ansin(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Antonces(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Apabila(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Around(*tag_expressions, &proc); end

  def Ataktiež(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ataké(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atesa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atiež(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atunci(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atès(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Avast(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aye(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Azároveň(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def BUT(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bagi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Banjur(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Before(*tag_expressions, &proc); end

  def Bet(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bila(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Biết(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Blimey(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Buh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def But(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ButattheendofthedayIreckon(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cal(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cand(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ce(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cho(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcásgo(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcásgur(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcásnach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcásnár(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Când(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def DEN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def DaHghubejlu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadas(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadena(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadeno(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dado(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dados(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daes(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daos(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Data(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Date(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datefiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datfiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dati(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datăfiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dau(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daus(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daţifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dațifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def De(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dengan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Denyousegotta(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diasumsikan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diberi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diketahui(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diyelimki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Do(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donc(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donitaĵo(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Duota(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dáu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def E(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Eeldades(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ef(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def En(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entao(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entonces(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Então(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entón(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entós(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Epi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Et(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonné(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnée(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnées(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnéqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnéque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnés(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Eğerki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Fakat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gangway(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gdy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegebensei(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegebenseien(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegeven(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegewe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gitt(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Given(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Givet(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Givun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ha(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Həm(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def I(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ICANHAZ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def In(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ir(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Itsjustunbelievable(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ja(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jeśli(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jeżeli(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kad(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kadar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kai(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kaj(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Když(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kemudian(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ketika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Keď(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Khi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kiedy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ko(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Koga(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Komence(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kui(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kuid(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Le(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lesaa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Letgoandhaul(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Logo(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lorsqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lorsque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lè(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lèsaa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ma(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mais(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maisqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maisque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Majd(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mając(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maka(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Manawa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mas(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Men(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Menawa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mutta(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nalika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nalikaning(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nanging(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nhưng(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Niin(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Njuk(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def No(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuaira(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairba(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairnach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairnár(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def När(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Når(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nəvaxtki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Och(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Og(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ohalda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Oletetaan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ond(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Onda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Oraz(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ozaman(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ParameterType(options); end

  def Pero(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Peru(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Però(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Podano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pokiaľ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pokud(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Potem(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Potom(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Privzeto(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pryd(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quand(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachant(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachantqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachantque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Se(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sed(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Si(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Siis(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sipoze(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def SipozeKe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sipozeke(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Soit(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Stel(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Så(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tad(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Takrat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tapi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ter(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tetapi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tha(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Thathe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Then(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Thurh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Thì(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Toda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Togash(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tooright(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tutaqki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ukoliko(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Un(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Und(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ve(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Vendar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Verilir(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Và(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Və(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def WEN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wanneer(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wenn(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def When(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def World(*world_modules, **namespaced_world_modules, &proc); end

  def Wtedy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Y(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ya(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yeahnah(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yknow(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yna(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Youseknowlikewhen(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Youseknowwhenyousegot(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadani(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadate(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadati(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zakładając(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zakładającże(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zapredpokladu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zapředpokladu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zaradi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zatim(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def a(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def an(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def awer(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def dann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ej(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ghunoblu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def if_nil(value, default); end

  def latlh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def mä(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def qaSDI(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def register_rb_step_definition(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ugeholl(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def vaj(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def wann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def És(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonné(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonnée(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonnées(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonnéqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonnéque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Étantdonnés(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ða(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ðaðe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ðurh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Þa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Þaþe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Þegar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Þurh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Þá(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Če(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Şi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Əgər(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Și(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Όταν(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Αλλά(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Δεδομένου(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Και(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Τότε(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def І(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def А(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Агар(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Але(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Али(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Аммо(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Анх(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Атакож(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Бирок(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ва(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Вә(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Гэхдээ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Дадена(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Дадено(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Дано(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Допустим(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Если(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Задате(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Задати(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Задато(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Затем(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def И(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Иначе(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Кад(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Када(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Кога(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Когато(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Когда(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Коли(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ктомуже(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Лекин(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ләкин(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Мөн(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Нехай(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Но(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Нәтиҗәдә(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Онда(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Припустимо(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Припустимощо(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Пусть(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Та(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Также(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def То(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Тогаш(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Тогда(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Тоді(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Тэгэхэд(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Тэгээд(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Унда(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Харин(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Хэрэв(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Якщо(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Үүнийдараа(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Һәм(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Әгәр(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Әйтик(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Әмма(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Өгөгдсөннь(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ապա(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Բայց(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Դիցուք(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Եթե(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Եվ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Երբ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def אבל(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def אז(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def אזי(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def בהינתן(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def וגם(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def כאשר(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def آنگاه(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def اذاً(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def اما(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def اور(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def اگر(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def بافرض(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def بالفرض(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def بفرض(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def تب(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ثم(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def جب(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def عندما(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def فرضکیا(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def لكن(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def لیکن(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def متى(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def هنگامی(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def و(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def پھر(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def अगर(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def अनी(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def आणि(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def और(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def कदा(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def किन्तु(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def चूंकि(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def जब(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def जर(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def जेव्हा(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तथा(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तदा(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तब(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तर(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तसेच(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def तेव्हा(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def त्यसपछि(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def दिइएको(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def दिएको(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def दिलेल्याप्रमाणे(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def पण(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def पर(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def परंतु(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def परन्तु(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def मग(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def यदि(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def र(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਅਤੇ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਜਦੋਂ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਜਿਵੇਂਕਿ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਜੇਕਰ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਤਦ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ਪਰ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def અને(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def આપેલછે(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ક્યારે(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def પછી(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def પણ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def அப்பொழுது(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ஆனால்(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def எப்போது(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def கொடுக்கப்பட்ட(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def மற்றும்(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def மேலும்(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def అప్పుడు(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ఈపరిస్థితిలో(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def కాని(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def చెప్పబడినది(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def మరియు(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ಆದರೆ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ನಂತರ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ನೀಡಿದ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ಮತ್ತು(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ಸ್ಥಿತಿಯನ್ನು(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def กำหนดให้(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ดังนั้น(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def เมื่อ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def แต่(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def และ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def და(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def მაშინ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def მოცემული(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def როდესაც(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def かつ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def しかし(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ただし(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ならば(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def もし(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 並且(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 但し(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 但是(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 假如(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 假定(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 假設(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 假设(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 前提(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 同时(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 同時(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 并且(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 当(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 當(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 而且(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 那么(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 那麼(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 그러면(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 그리고(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 단(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 만약(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 만일(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 먼저(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 조건(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def 하지만(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end
end

module Cucumber::Glue::Dsl
  def self.alias_adverb(adverb); end

  def self.build_rb_world_factory(world_modules, namespaced_world_modules, proc); end

  def self.define_parameter_type(parameter_type); end

  def self.rb_language=(rb_language); end

  def self.register_rb_hook(phase, tag_names, proc); end

  def self.register_rb_step_definition(regexp, proc_or_sym, options=T.unsafe(nil)); end
end

class Cucumber::Glue::InvokeInWorld
  INSTANCE_EXEC_OFFSET = ::T.let(nil, ::T.untyped)
end

Cucumber::Glue::ProtoWorld::AnsiEscapes = Cucumber::Gherkin::Formatter::AnsiEscapes

module Cucumber::Glue::Snippet
  ARGUMENT_PATTERNS = ::T.let(nil, ::T.untyped)
  SNIPPET_TYPES = ::T.let(nil, ::T.untyped)
end

module Cucumber::Glue
  def self.backtrace_line(proc, name); end
end

module Cucumber::Hooks
end

class Cucumber::Hooks::AfterHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::AfterHook
end

class Cucumber::Hooks::AfterStepHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::AfterStepHook
end

class Cucumber::Hooks::BeforeHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::BeforeHook
end

module Cucumber::Hooks
  def self.after_hook(id, location, &block); end

  def self.after_step_hook(id, test_step, location, &block); end

  def self.around_hook(&block); end

  def self.before_hook(id, location, &block); end
end

module Cucumber::LoadPath
end

module Cucumber::LoadPath
  def self.add_dirs(*dirs); end
end

module Cucumber::Messages
  include ::Protobuf::Optionable
  VERSION = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Attachment
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Attachment::ContentEncoding
  BASE64 = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Duration
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Envelope
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Comment
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Background
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::FeatureChild
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::FeatureChild::Rule
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::FeatureChild::RuleChild
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Scenario
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Scenario::Examples
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Step
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Step::DataTable
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Step::DocString
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::TableRow
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::TableRow::TableCell
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::GherkinDocument::Feature::Tag
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Hook
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Location
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Meta
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Meta::CI
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Meta::CI::Git
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Meta::Product
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::ParameterType
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::ParseError
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Pickle
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Pickle::PickleStep
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Pickle::PickleTag
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepArgument
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepArgument::PickleDocString
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepArgument::PickleTable
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepArgument::PickleTable::PickleTableRow
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepArgument::PickleTable::PickleTableRow::PickleTableCell
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Source
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::SourceReference
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::SourceReference::JavaMethod
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::SourceReference::JavaStackTraceElement
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::StepDefinition
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::StepDefinition::StepDefinitionPattern
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::StepDefinition::StepDefinitionPattern::StepDefinitionPatternType
  CUCUMBER_EXPRESSION = ::T.let(nil, ::T.untyped)
  REGULAR_EXPRESSION = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCase
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCase::TestStep
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCase::TestStep::StepMatchArgumentsList
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCase::TestStep::StepMatchArgumentsList::StepMatchArgument
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCase::TestStep::StepMatchArgumentsList::StepMatchArgument::Group
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCaseFinished
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestCaseStarted
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestRunFinished
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestRunStarted
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestStepFinished
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestStepFinished::TestStepResult
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestStepFinished::TestStepResult::Status
  AMBIGUOUS = ::T.let(nil, ::T.untyped)
  FAILED = ::T.let(nil, ::T.untyped)
  PASSED = ::T.let(nil, ::T.untyped)
  PENDING = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  SKIPPED = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestStepStarted
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

module Cucumber::Messages::TimeConversion
  NANOSECONDS_PER_SECOND = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Timestamp
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::UndefinedParameterType
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

module Cucumber::Messages
  extend ::Protobuf::Optionable::ClassMethods
end

module Cucumber::MultilineArgument
end

class Cucumber::MultilineArgument::DataTable
  def append_to(array); end

  def build_hashes(); end

  def cell_matrix(); end

  def cells_rows(); end

  def cells_to_hash(cells); end

  def clear_cache!(); end

  def col_width(col); end

  def column_names(); end

  def columns(); end

  def convert_columns!(); end

  def convert_headers!(); end

  def create_cell_matrix(ast_table); end

  def describe_to(visitor, *args); end

  def diff!(other_table, options=T.unsafe(nil)); end

  def each_cells_row(&proc); end

  def ensure_table(table_or_array); end

  def file(); end

  def file=(file); end

  def hashes(); end

  def header_cell(col); end

  def headers(); end

  def index(cells); end

  def initialize(data, conversion_procs=T.unsafe(nil), header_mappings=T.unsafe(nil), header_conversion_proc=T.unsafe(nil)); end

  def location(); end

  def map_column(column_name, strict=T.unsafe(nil), &conversion_proc); end

  def map_column!(column_name, strict=T.unsafe(nil), &conversion_proc); end

  def map_headers(mappings=T.unsafe(nil), &block); end

  def map_headers!(mappings=T.unsafe(nil), &block); end

  def match(pattern); end

  def raw(); end

  def rows(); end

  def rows_hash(); end

  def symbolic_hashes(); end

  def symbolize_key(key); end

  def text?(text); end

  def to_hash(); end

  def to_json(*args); end

  def to_s(options=T.unsafe(nil)); end

  def to_step_definition_arg(); end

  def transpose(); end

  def verify_column(column_name); end

  def verify_table_width(width); end
  NULL_CONVERSIONS = ::T.let(nil, ::T.untyped)
end

class Cucumber::MultilineArgument::DataTable::Builder
  def eof(); end

  def row(row); end

  def rows(); end
end

class Cucumber::MultilineArgument::DataTable::Builder
end

class Cucumber::MultilineArgument::DataTable::Cell
  def ==(other); end

  def eql?(other); end

  def initialize(value, table, line); end

  def inspect!(); end

  def line(); end

  def status(); end

  def status=(status); end

  def table(); end

  def to_sexp(); end

  def value(); end

  def value=(value); end
end

class Cucumber::MultilineArgument::DataTable::Cell
end

class Cucumber::MultilineArgument::DataTable::Cells
  include ::Enumerable
  include ::Cucumber::Gherkin::Formatter::Escaping
  def [](n); end

  def accept(visitor); end

  def dom_id(); end

  def each(&proc); end

  def exception(); end

  def initialize(table, cells); end

  def line(); end

  def to_hash(); end

  def to_sexp(); end

  def value(n); end
end

class Cucumber::MultilineArgument::DataTable::Cells
end

class Cucumber::MultilineArgument::DataTable::DataTablePrinter
  include ::Cucumber::Gherkin::Formatter::Escaping
  def initialize(data_table, indentation, prefixes); end
end

class Cucumber::MultilineArgument::DataTable::DataTablePrinter
end

class Cucumber::MultilineArgument::DataTable::Different
  def initialize(table); end

  def table(); end
end

class Cucumber::MultilineArgument::DataTable::Different
end

class Cucumber::MultilineArgument::DataTable::SurplusCell
  def ==(_other); end
end

class Cucumber::MultilineArgument::DataTable::SurplusCell
end

class Cucumber::MultilineArgument::DataTable
  def self.default_arg_name(); end

  def self.from(data); end
end

class Cucumber::MultilineArgument::DocString
  def append_to(array); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::MultilineArgument::DocString
end

class Cucumber::MultilineArgument::None
  def append_to(array); end

  def describe_to(visitor); end
end

class Cucumber::MultilineArgument::None
end

module Cucumber::MultilineArgument
  def self.from(argument, location=T.unsafe(nil), content_type=T.unsafe(nil)); end

  def self.from_core(node); end
end

class Cucumber::NoStepMatch
  def activate(test_step); end

  def backtrace_line(); end

  def file_colon_line(); end

  def format_args(*_args); end

  def initialize(step, name); end

  def location(); end

  def name(); end

  def step_arguments(); end

  def step_definition(); end

  def text_length(); end
end

class Cucumber::NoStepMatch
end

class Cucumber::Pending
end

class Cucumber::Pending
end

module Cucumber::RunningTestCase
end

class Cucumber::RunningTestCase::TestCase
  def accept_hook?(hook); end

  def exception(); end

  def failed?(); end

  def initialize(test_case, result=T.unsafe(nil)); end

  def passed?(); end

  def source_tag_names(); end

  def status(); end

  def with_result(result); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::RunningTestCase::TestCase
end

module Cucumber::RunningTestCase
  def self.new(test_case); end
end

class Cucumber::Runtime
  include ::Cucumber::Core
  include ::Cucumber::Formatter::Duration
  include ::Cucumber::Runtime::UserInterface
  def begin_scenario(test_case); end

  def configuration(); end

  def configure(new_configuration); end

  def doc_string(string_without_triple_quotes, content_type=T.unsafe(nil), _line_offset=T.unsafe(nil)); end

  def dry_run?(); end

  def end_scenario(_scenario); end

  def failure?(); end

  def features_paths(); end

  def initialize(configuration=T.unsafe(nil)); end

  def results(); end

  def run!(); end

  def support_code(); end

  def unmatched_step_definitions(); end
end

class Cucumber::Runtime::AfterHooks
  def apply_to(test_case); end

  def initialize(id_generator, hooks, scenario, event_bus); end
end

class Cucumber::Runtime::AfterHooks
end

class Cucumber::Runtime::BeforeHooks
  def apply_to(test_case); end

  def initialize(id_generator, hooks, scenario, event_bus); end
end

class Cucumber::Runtime::BeforeHooks
end

class Cucumber::Runtime::ForProgrammingLanguages
  def ask(*args, &block); end

  def attach(*args, &block); end

  def embed(*args, &block); end

  def features_paths(*args, &block); end

  def initialize(support_code, user_interface); end

  def invoke_dynamic_step(*args, &block); end

  def invoke_dynamic_steps(*args, &block); end

  def puts(*args, &block); end

  def step_match(*args, &block); end

  def support_code(); end
end

class Cucumber::Runtime::ForProgrammingLanguages
  extend ::Forwardable
end

class Cucumber::Runtime::NormalisedEncodingFile
  COMMENT_OR_EMPTY_LINE_PATTERN = ::T.let(nil, ::T.untyped)
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Runtime::StepHooks
  def apply(test_steps); end

  def initialize(id_generator, hooks, event_bus); end
end

class Cucumber::Runtime::StepHooks
end

class Cucumber::Runtime::SupportCode
  include ::Cucumber::Constantize
  def apply_after_hooks(test_case); end

  def apply_before_hooks(test_case); end

  def configure(new_configuration); end

  def find_after_step_hooks(test_case); end

  def find_around_hooks(test_case); end

  def fire_hook(name, *args); end

  def initialize(user_interface, configuration=T.unsafe(nil)); end

  def invoke_dynamic_step(step_name, multiline_argument, _location=T.unsafe(nil)); end

  def invoke_dynamic_steps(steps_text, iso_code, _location); end

  def load_files!(files); end

  def load_files_from_paths(paths); end

  def registry(); end

  def step_definitions(); end

  def unmatched_step_definitions(); end
end

class Cucumber::Runtime::SupportCode::StepInvoker
  def initialize(support_code); end

  def multiline_arg(step, location); end

  def step(step); end

  def steps(steps); end
end

class Cucumber::Runtime::SupportCode::StepInvoker
end

class Cucumber::Runtime::SupportCode
end

module Cucumber::Runtime::UserInterface
  def ask(question, timeout_seconds); end

  def attach(src, media_type); end

  def visitor=(visitor); end
end

module Cucumber::Runtime::UserInterface
end

class Cucumber::SkippingStepMatch
  def activate(test_step); end
end

class Cucumber::SkippingStepMatch
end

class Cucumber::StepMatch
  def activate(test_step); end

  def args(); end

  def backtrace_line(); end

  def file_colon_line(); end

  def format_args(format=T.unsafe(nil), &proc); end

  def initialize(step_definition, step_name, step_arguments); end

  def invoke(multiline_arg); end

  def location(); end

  def replace_arguments(string, step_arguments, format); end

  def step_arguments(); end

  def step_definition(); end

  def text_length(); end
end

class Cucumber::StepMatch
end

module Cucumber::StepMatchSearch
end

class Cucumber::StepMatchSearch::AssertUnambiguousMatch
  def call(step_name); end

  def initialize(search, configuration); end
end

class Cucumber::StepMatchSearch::AssertUnambiguousMatch
end

class Cucumber::StepMatchSearch::AttemptToGuessAmbiguousMatch
  def call(step_name); end

  def initialize(search); end
end

class Cucumber::StepMatchSearch::AttemptToGuessAmbiguousMatch
end

class Cucumber::StepMatchSearch::CachesStepMatch
  def call(step_name); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::StepMatchSearch::CachesStepMatch
end

module Cucumber::StepMatchSearch
  def self.new(search, configuration); end
end

class Cucumber::TagExcess
  def initialize(messages); end
end

class Cucumber::TagExcess
end

module Cucumber::Term::ANSIColor
  def black(string=T.unsafe(nil)); end

  def blink(string=T.unsafe(nil)); end

  def blue(string=T.unsafe(nil)); end

  def bold(string=T.unsafe(nil)); end

  def clear(string=T.unsafe(nil)); end

  def concealed(string=T.unsafe(nil)); end

  def cyan(string=T.unsafe(nil)); end

  def dark(string=T.unsafe(nil)); end

  def green(string=T.unsafe(nil)); end

  def italic(string=T.unsafe(nil)); end

  def magenta(string=T.unsafe(nil)); end

  def negative(string=T.unsafe(nil)); end

  def on_black(string=T.unsafe(nil)); end

  def on_blue(string=T.unsafe(nil)); end

  def on_cyan(string=T.unsafe(nil)); end

  def on_green(string=T.unsafe(nil)); end

  def on_magenta(string=T.unsafe(nil)); end

  def on_red(string=T.unsafe(nil)); end

  def on_white(string=T.unsafe(nil)); end

  def on_yellow(string=T.unsafe(nil)); end

  def rapid_blink(string=T.unsafe(nil)); end

  def red(string=T.unsafe(nil)); end

  def reset(string=T.unsafe(nil)); end

  def strikethrough(string=T.unsafe(nil)); end

  def uncolored(string=T.unsafe(nil)); end

  def underline(string=T.unsafe(nil)); end

  def underscore(string=T.unsafe(nil)); end

  def white(string=T.unsafe(nil)); end

  def yellow(string=T.unsafe(nil)); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
  COLORED_REGEXP = ::T.let(nil, ::T.untyped)
end

module Cucumber::Term::ANSIColor
  def self.attributes(); end

  def self.coloring=(val); end

  def self.coloring?(); end

  def self.included(klass); end
end

class Cucumber::Undefined
end

class Cucumber::Undefined
  def self.from(result, step_name); end

  def self.with_prefix(step_name); end
end

class Cucumber::UndefinedDynamicStep
  def initialize(step_name); end
end

class Cucumber::UndefinedDynamicStep
end

class Cucumber::Wire::Configuration
  DEFAULT_TIMEOUTS = ::T.let(nil, ::T.untyped)
end

module Cucumber
  def self.deprecate(*args); end

  def self.file_mode(mode, encoding=T.unsafe(nil)); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.use_full_backtrace(); end

  def self.use_full_backtrace=(use_full_backtrace); end

  def self.use_legacy_autoloader(); end

  def self.use_legacy_autoloader=(use_legacy_autoloader); end

  def self.wants_to_quit(); end

  def self.wants_to_quit=(wants_to_quit); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  include ::DateAndTime::Zones
  def default_inspect(); end

  def infinite?(); end

  def readable_inspect(); end

  def to_default_s(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

class DateTime
  def advance(options); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def in(seconds); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def noon(); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end

  def self.current(); end
end

module Declarative::Schema::DSL
  NestedBuilder = ::T.let(nil, ::T.untyped)
end

module DeepMerge
  DEFAULT_FIELD_KNOCKOUT_PREFIX = ::T.let(nil, ::T.untyped)
end

class Delegator
  include ::ActiveSupport::Tryable
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

module Equatable
  VERSION = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module Excon
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CR_NL = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_CA_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIRECT_LIMIT = ::T.let(nil, ::T.untyped)
  DEFAULT_RETRY_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_RETRY_LIMIT = ::T.let(nil, ::T.untyped)
  DEPRECATED_VALID_REQUEST_KEYS = ::T.let(nil, ::T.untyped)
  FORCE_ENC = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_1_1 = ::T.let(nil, ::T.untyped)
  HTTP_VERBS = ::T.let(nil, ::T.untyped)
  NO_ENTITY = ::T.let(nil, ::T.untyped)
  REDACTED = ::T.let(nil, ::T.untyped)
  UNIX = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  VALID_CONNECTION_KEYS = ::T.let(nil, ::T.untyped)
  VALID_REQUEST_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSIONS = ::T.let(nil, ::T.untyped)
end

Excon::Errors::Accepted = Excon::Error::Accepted

Excon::Errors::BadGateway = Excon::Error::BadGateway

Excon::Errors::BadRequest = Excon::Error::BadRequest

Excon::Errors::CertificateError = Excon::Error::Certificate

Excon::Errors::ClientError = Excon::Error::Client

Excon::Errors::Conflict = Excon::Error::Conflict

Excon::Errors::Continue = Excon::Error::Continue

Excon::Errors::Created = Excon::Error::Created

Excon::Errors::Error = Excon::Error

Excon::Errors::ExpectationFailed = Excon::Error::ExpectationFailed

Excon::Errors::Forbidden = Excon::Error::Forbidden

Excon::Errors::Found = Excon::Error::Found

Excon::Errors::GatewayTimeout = Excon::Error::GatewayTimeout

Excon::Errors::Gone = Excon::Error::Gone

Excon::Errors::HTTPStatusError = Excon::Error::HTTPStatus

Excon::Errors::Informational = Excon::Error::Informational

Excon::Errors::InternalServerError = Excon::Error::InternalServerError

Excon::Errors::InvalidHeaderKey = Excon::Error::InvalidHeaderKey

Excon::Errors::InvalidHeaderValue = Excon::Error::InvalidHeaderValue

Excon::Errors::InvalidStub = Excon::Error::InvalidStub

Excon::Errors::LengthRequired = Excon::Error::LengthRequired

Excon::Errors::MethodNotAllowed = Excon::Error::MethodNotAllowed

Excon::Errors::MovedPermanently = Excon::Error::MovedPermanently

Excon::Errors::MultipleChoices = Excon::Error::MultipleChoices

Excon::Errors::NoContent = Excon::Error::NoContent

Excon::Errors::NonAuthoritativeInformation = Excon::Error::NonAuthoritativeInformation

Excon::Errors::NotAcceptable = Excon::Error::NotAcceptable

Excon::Errors::NotFound = Excon::Error::NotFound

Excon::Errors::NotImplemented = Excon::Error::NotImplemented

Excon::Errors::NotModified = Excon::Error::NotModified

Excon::Errors::OK = Excon::Error::OK

Excon::Errors::PartialContent = Excon::Error::PartialContent

Excon::Errors::PaymentRequired = Excon::Error::PaymentRequired

Excon::Errors::PreconditionFailed = Excon::Error::PreconditionFailed

Excon::Errors::ProxyAuthenticationRequired = Excon::Error::ProxyAuthenticationRequired

Excon::Errors::ProxyConnectionError = Excon::Error::ProxyConnectionError

Excon::Errors::ProxyParse = Excon::Error::ProxyParse

Excon::Errors::Redirection = Excon::Error::Redirection

Excon::Errors::RequestEntityTooLarge = Excon::Error::RequestEntityTooLarge

Excon::Errors::RequestTimeout = Excon::Error::RequestTimeout

Excon::Errors::RequestURITooLong = Excon::Error::RequestURITooLong

Excon::Errors::RequestedRangeNotSatisfiable = Excon::Error::RequestedRangeNotSatisfiable

Excon::Errors::ResetContent = Excon::Error::ResetContent

Excon::Errors::ResponseParse = Excon::Error::ResponseParse

Excon::Errors::SeeOther = Excon::Error::SeeOther

Excon::Errors::ServerError = Excon::Error::Server

Excon::Errors::ServiceUnavailable = Excon::Error::ServiceUnavailable

Excon::Errors::SocketError = Excon::Error::Socket

Excon::Errors::StubNotFound = Excon::Error::StubNotFound

Excon::Errors::Success = Excon::Error::Success

Excon::Errors::SwitchingProtocols = Excon::Error::SwitchingProtocols

Excon::Errors::TemporaryRedirect = Excon::Error::TemporaryRedirect

Excon::Errors::Timeout = Excon::Error::Timeout

Excon::Errors::TooManyRedirects = Excon::Error::TooManyRedirects

Excon::Errors::TooManyRequests = Excon::Error::TooManyRequests

Excon::Errors::Unauthorized = Excon::Error::Unauthorized

Excon::Errors::UnprocessableEntity = Excon::Error::UnprocessableEntity

Excon::Errors::UnsupportedMediaType = Excon::Error::UnsupportedMediaType

Excon::Errors::UseProxy = Excon::Error::UseProxy

Excon::Errors::Warning = Excon::Error::Warning

class Excon::Headers
  SENTINEL = ::T.let(nil, ::T.untyped)
end

class Excon::SSLSocket
  HAVE_NONBLOCK = ::T.let(nil, ::T.untyped)
end

class Excon::Socket
  CONNECT_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  READ_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  WRITE_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
end

module Excon::Utils
  CONTROL = ::T.let(nil, ::T.untyped)
  DELIMS = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  UNESCAPED = ::T.let(nil, ::T.untyped)
  UNWISE = ::T.let(nil, ::T.untyped)
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

FFI::CallbackInfo = FFI::FunctionType

class FFI::DynamicLibrary
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

FFI::FunctionInfo = FFI::FunctionType

module FFI::Library
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Struct::InlineArray
  include ::Enumerable
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayoutBuilder
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::Type
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

FFI::Type::Function = FFI::FunctionType

FFI::Type::Struct = FFI::StructByValue

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Faraday
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end

  def timeout_message?(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(&block); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::HTTPClient
  def build_connection(env); end

  def configure_client(client); end

  def configure_proxy(client, proxy); end

  def configure_socket(client, bind); end

  def configure_ssl(client, ssl); end

  def configure_timeouts(client, req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
  def build_connection(env); end

  def configure_proxy(session, proxy); end

  def configure_ssl(session, ssl); end

  def configure_timeouts(session, req); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Connection
  METHODS = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

module Faraday::Excon
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::FilePart = UploadIO

module Faraday::NetHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::NetHttpPersistent
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::Parts = Parts

class Faraday::RackBuilder
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

Faraday::Request::OAuth = FaradayMiddleware::OAuth

Faraday::Request::OAuth2 = FaradayMiddleware::OAuth2

class Faraday::Request::Retry
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::RequestOptions
  include ::FaradayMiddleware::OptionsExtension
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

Faraday::Response::Mashify = FaradayMiddleware::Mashify

Faraday::Response::ParseJson = FaradayMiddleware::ParseJson

Faraday::Response::ParseMarshal = FaradayMiddleware::ParseMarshal

Faraday::Response::ParseXml = FaradayMiddleware::ParseXml

Faraday::Response::ParseYaml = FaradayMiddleware::ParseYaml

class Faraday::Response::RaiseError
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

Faraday::Response::Rashify = FaradayMiddleware::Rashify

Faraday::Timer = Timeout

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  KeyMap = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Caching
  def build_query(*args, &block); end

  def cache(); end

  def cache_key(env); end

  def cache_on_complete(env); end

  def finalize_response(response, env); end

  def full_key?(); end

  def initialize(app, cache=T.unsafe(nil), options=T.unsafe(nil)); end

  def params_to_ignore(); end

  def parse_query(*args, &block); end

  def store_response_in_cache(key, response); end
  CACHEABLE_STATUS_CODES = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Caching
  extend ::Forwardable
end

class FaradayMiddleware::Chunked
  def chunked_encoding?(headers); end
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Chunked
end

class FaradayMiddleware::EncodeJson
  def encode(data); end

  def has_body?(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPE_REGEX = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::EncodeJson
end

class FaradayMiddleware::FollowRedirects
  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  AUTH_HEADER = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::FollowRedirects
end

class FaradayMiddleware::Gzip
  def brotli_inflate(body); end

  def inflate(body); end

  def raw_body(body); end

  def reset_body(env); end

  def uncompress_gzip(body); end
  ACCEPT_ENCODING = ::T.let(nil, ::T.untyped)
  BROTLI_SUPPORTED = ::T.let(nil, ::T.untyped)
  CONTENT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  SUPPORTED_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Gzip
  def self.optional_dependency(lib=T.unsafe(nil)); end

  def self.supported_encodings(); end
end

class FaradayMiddleware::Instrumentation
  def initialize(app, options=T.unsafe(nil)); end
end

class FaradayMiddleware::Instrumentation
end

class FaradayMiddleware::Mashify
  def mash_class(); end

  def mash_class=(mash_class); end

  def parse(body); end
end

class FaradayMiddleware::Mashify
  def self.mash_class(); end

  def self.mash_class=(mash_class); end
end

class FaradayMiddleware::MethodOverride
  def initialize(app, options=T.unsafe(nil)); end

  def rewrite_request(env, original_method); end

  def rewrite_request?(method); end
  HEADER = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::MethodOverride
end

class FaradayMiddleware::OAuth
  def body_params(env); end

  def include_body_params?(env); end

  def initialize(app, options); end

  def oauth_header(env); end

  def oauth_options(env); end

  def parse_nested_query(*args, &block); end

  def sign_request?(env); end

  def signature_params(params); end
  AUTH_HEADER = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_URLENCODED = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::OAuth
  extend ::Forwardable
end

class FaradayMiddleware::OAuth2
  def build_query(*args, &block); end

  def initialize(app, token=T.unsafe(nil), options=T.unsafe(nil)); end

  def param_name(); end

  def parse_query(*args, &block); end

  def query_params(url); end

  def token_type(); end
  AUTH_HEADER = ::T.let(nil, ::T.untyped)
  PARAM_NAME = ::T.let(nil, ::T.untyped)
  TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::OAuth2
  extend ::Forwardable
end

module FaradayMiddleware::OptionsExtension
  def each(&blk); end

  def fetch(key, *args); end

  def preserve_raw(); end

  def preserve_raw=(preserve_raw); end

  def to_hash(); end
end

module FaradayMiddleware::OptionsExtension
end

class FaradayMiddleware::ParseDates
  def initialize(app, options=T.unsafe(nil)); end
  ISO_DATE_FORMAT = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ParseDates
end

class FaradayMiddleware::ParseJson
end

class FaradayMiddleware::ParseJson::MimeTypeFix
  def first_char(body); end
  BRACKETS = ::T.let(nil, ::T.untyped)
  MIME_TYPE = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ParseJson::MimeTypeFix
end

class FaradayMiddleware::ParseJson
end

class FaradayMiddleware::ParseMarshal
end

class FaradayMiddleware::ParseMarshal
end

class FaradayMiddleware::ParseXml
end

class FaradayMiddleware::ParseXml
end

class FaradayMiddleware::ParseYaml
end

class FaradayMiddleware::ParseYaml
end

class FaradayMiddleware::RackCompatible
  def call(env); end

  def finalize_response(env, rack_response); end

  def headers_to_rack(env); end

  def initialize(app, rack_handler, *args); end

  def prepare_env(faraday_env); end

  def restore_env(rack_env); end
  NON_PREFIXED_HEADERS = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::RackCompatible
end

class FaradayMiddleware::Rashify
end

class FaradayMiddleware::Rashify
end

class FaradayMiddleware::RedirectLimitReached
  def initialize(response); end
end

class FaradayMiddleware::RedirectLimitReached
end

class FaradayMiddleware::ResponseMiddleware
  def call(environment); end

  def parse(body); end

  def parse_response?(env); end

  def preserve_raw?(env); end

  def process_response(env); end

  def process_response_type?(type); end

  def response_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ResponseMiddleware
  def self.define_parser(parser=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.parser=(parser); end
end

class Fiber
  def initialize(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end
end

class File
  def self.absolute_path?(_); end

  def self.exists?(_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Formatador
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  PARSE_REGEX = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  include ::Gem::Requirement::OrderIndependentComparison
  include ::Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::CorrectHashForLambdaOperator
  def hash(); end
end

module Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::OrderIndependentComparison
  def ==(other); end

  def _requirements_sorted?(); end

  def _with_sorted_requirements(); end
end

module Gem::Requirement::OrderIndependentComparison
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gherkin
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DIALECTS = ::T.let(nil, ::T.untyped)
  DIALECT_FILE_PATH = ::T.let(nil, ::T.untyped)
  RULE_TYPE = ::T.let(nil, ::T.untyped)
end

class Gherkin::TokenMatcher
  LANGUAGE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Google
end

module Google::Protobuf
  include ::Protobuf::Optionable
end

module Google::Protobuf::Compiler
  include ::Protobuf::Optionable
end

class Google::Protobuf::Compiler::CodeGeneratorRequest
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def file_to_generate(); end

  def file_to_generate!(); end

  def file_to_generate=(v); end

  def parameter(); end

  def parameter!(); end

  def parameter=(v); end

  def proto_file(); end

  def proto_file!(); end

  def proto_file=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::Compiler::CodeGeneratorRequest
end

class Google::Protobuf::Compiler::CodeGeneratorResponse
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def error(); end

  def error!(); end

  def error=(v); end

  def file(); end

  def file!(); end

  def file=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::Compiler::CodeGeneratorResponse::File
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def content(); end

  def content!(); end

  def content=(v); end

  def insertion_point(); end

  def insertion_point!(); end

  def insertion_point=(v); end

  def name(); end

  def name!(); end

  def name=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::Compiler::CodeGeneratorResponse::File
end

class Google::Protobuf::Compiler::CodeGeneratorResponse
end

module Google::Protobuf::Compiler
  extend ::Protobuf::Optionable::ClassMethods
  def self.optionable_descriptor_class(); end
end

class Google::Protobuf::DescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def enum_type(); end

  def enum_type!(); end

  def enum_type=(v); end

  def extension(); end

  def extension!(); end

  def extension=(v); end

  def extension_range(); end

  def extension_range!(); end

  def extension_range=(v); end

  def field(); end

  def field!(); end

  def field=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def nested_type(); end

  def nested_type!(); end

  def nested_type=(v); end

  def oneof_decl(); end

  def oneof_decl!(); end

  def oneof_decl=(v); end

  def options(); end

  def options!(); end

  def options=(v); end

  def reserved_name(); end

  def reserved_name!(); end

  def reserved_name=(v); end

  def reserved_range(); end

  def reserved_range!(); end

  def reserved_range=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::DescriptorProto::ExtensionRange
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def end(); end

  def end!(); end

  def end=(v); end

  def start(); end

  def start!(); end

  def start=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::DescriptorProto::ExtensionRange
end

class Google::Protobuf::DescriptorProto::ReservedRange
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def end(); end

  def end!(); end

  def end=(v); end

  def start(); end

  def start!(); end

  def start=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::DescriptorProto::ReservedRange
end

class Google::Protobuf::DescriptorProto
end

class Google::Protobuf::EnumDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def name(); end

  def name!(); end

  def name=(v); end

  def options(); end

  def options!(); end

  def options=(v); end

  def value(); end

  def value!(); end

  def value=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::EnumDescriptorProto
end

class Google::Protobuf::EnumOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def allow_alias(); end

  def allow_alias!(); end

  def allow_alias=(v); end

  def allow_alias?(); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::EnumOptions
end

class Google::Protobuf::EnumValueDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def name(); end

  def name!(); end

  def name=(v); end

  def number(); end

  def number!(); end

  def number=(v); end

  def options(); end

  def options!(); end

  def options=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::EnumValueDescriptorProto
end

class Google::Protobuf::EnumValueOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::EnumValueOptions
end

class Google::Protobuf::FieldDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def default_value(); end

  def default_value!(); end

  def default_value=(v); end

  def extendee(); end

  def extendee!(); end

  def extendee=(v); end

  def json_name(); end

  def json_name!(); end

  def json_name=(v); end

  def label(); end

  def label!(); end

  def label=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def number(); end

  def number!(); end

  def number=(v); end

  def oneof_index(); end

  def oneof_index!(); end

  def oneof_index=(v); end

  def options(); end

  def options!(); end

  def options=(v); end

  def type(); end

  def type!(); end

  def type=(v); end

  def type_name(); end

  def type_name!(); end

  def type_name=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldDescriptorProto::Label
  LABEL_OPTIONAL = ::T.let(nil, ::T.untyped)
  LABEL_REPEATED = ::T.let(nil, ::T.untyped)
  LABEL_REQUIRED = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldDescriptorProto::Label
end

class Google::Protobuf::FieldDescriptorProto::Type
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BYTES = ::T.let(nil, ::T.untyped)
  TYPE_DOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_ENUM = ::T.let(nil, ::T.untyped)
  TYPE_FIXED32 = ::T.let(nil, ::T.untyped)
  TYPE_FIXED64 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT = ::T.let(nil, ::T.untyped)
  TYPE_GROUP = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_MESSAGE = ::T.let(nil, ::T.untyped)
  TYPE_SFIXED32 = ::T.let(nil, ::T.untyped)
  TYPE_SFIXED64 = ::T.let(nil, ::T.untyped)
  TYPE_SINT32 = ::T.let(nil, ::T.untyped)
  TYPE_SINT64 = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldDescriptorProto::Type
end

class Google::Protobuf::FieldDescriptorProto
end

class Google::Protobuf::FieldOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def ctype(); end

  def ctype!(); end

  def ctype=(v); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def jstype(); end

  def jstype!(); end

  def jstype=(v); end

  def lazy(); end

  def lazy!(); end

  def lazy=(v); end

  def lazy?(); end

  def packed(); end

  def packed!(); end

  def packed=(v); end

  def packed?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end

  def weak(); end

  def weak!(); end

  def weak=(v); end

  def weak?(); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldOptions::CType
  CORD = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRING_PIECE = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldOptions::CType
end

class Google::Protobuf::FieldOptions::JSType
  JS_NORMAL = ::T.let(nil, ::T.untyped)
  JS_NUMBER = ::T.let(nil, ::T.untyped)
  JS_STRING = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FieldOptions::JSType
end

class Google::Protobuf::FieldOptions
end

class Google::Protobuf::FileDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def dependency(); end

  def dependency!(); end

  def dependency=(v); end

  def enum_type(); end

  def enum_type!(); end

  def enum_type=(v); end

  def extension(); end

  def extension!(); end

  def extension=(v); end

  def message_type(); end

  def message_type!(); end

  def message_type=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def options(); end

  def options!(); end

  def options=(v); end

  def package(); end

  def package!(); end

  def package=(v); end

  def public_dependency(); end

  def public_dependency!(); end

  def public_dependency=(v); end

  def service(); end

  def service!(); end

  def service=(v); end

  def source_code_info(); end

  def source_code_info!(); end

  def source_code_info=(v); end

  def syntax(); end

  def syntax!(); end

  def syntax=(v); end

  def weak_dependency(); end

  def weak_dependency!(); end

  def weak_dependency=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FileDescriptorProto
end

class Google::Protobuf::FileDescriptorSet
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def file(); end

  def file!(); end

  def file=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FileDescriptorSet
end

class Google::Protobuf::FileOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def cc_enable_arenas(); end

  def cc_enable_arenas!(); end

  def cc_enable_arenas=(v); end

  def cc_enable_arenas?(); end

  def cc_generic_services(); end

  def cc_generic_services!(); end

  def cc_generic_services=(v); end

  def cc_generic_services?(); end

  def csharp_namespace(); end

  def csharp_namespace!(); end

  def csharp_namespace=(v); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def go_package(); end

  def go_package!(); end

  def go_package=(v); end

  def java_generate_equals_and_hash(); end

  def java_generate_equals_and_hash!(); end

  def java_generate_equals_and_hash=(v); end

  def java_generate_equals_and_hash?(); end

  def java_generic_services(); end

  def java_generic_services!(); end

  def java_generic_services=(v); end

  def java_generic_services?(); end

  def java_multiple_files(); end

  def java_multiple_files!(); end

  def java_multiple_files=(v); end

  def java_multiple_files?(); end

  def java_outer_classname(); end

  def java_outer_classname!(); end

  def java_outer_classname=(v); end

  def java_package(); end

  def java_package!(); end

  def java_package=(v); end

  def java_string_check_utf8(); end

  def java_string_check_utf8!(); end

  def java_string_check_utf8=(v); end

  def java_string_check_utf8?(); end

  def javanano_use_deprecated_package(); end

  def javanano_use_deprecated_package!(); end

  def javanano_use_deprecated_package=(v); end

  def javanano_use_deprecated_package?(); end

  def objc_class_prefix(); end

  def objc_class_prefix!(); end

  def objc_class_prefix=(v); end

  def optimize_for(); end

  def optimize_for!(); end

  def optimize_for=(v); end

  def py_generic_services(); end

  def py_generic_services!(); end

  def py_generic_services=(v); end

  def py_generic_services?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FileOptions::OptimizeMode
  CODE_SIZE = ::T.let(nil, ::T.untyped)
  LITE_RUNTIME = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  SPEED = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::FileOptions::OptimizeMode
end

class Google::Protobuf::FileOptions
end

class Google::Protobuf::MessageOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def map_entry(); end

  def map_entry!(); end

  def map_entry=(v); end

  def map_entry?(); end

  def message_set_wire_format(); end

  def message_set_wire_format!(); end

  def message_set_wire_format=(v); end

  def message_set_wire_format?(); end

  def no_standard_descriptor_accessor(); end

  def no_standard_descriptor_accessor!(); end

  def no_standard_descriptor_accessor=(v); end

  def no_standard_descriptor_accessor?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::MessageOptions
end

class Google::Protobuf::MethodDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def client_streaming(); end

  def client_streaming!(); end

  def client_streaming=(v); end

  def client_streaming?(); end

  def input_type(); end

  def input_type!(); end

  def input_type=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def options(); end

  def options!(); end

  def options=(v); end

  def output_type(); end

  def output_type!(); end

  def output_type=(v); end

  def server_streaming(); end

  def server_streaming!(); end

  def server_streaming=(v); end

  def server_streaming?(); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::MethodDescriptorProto
end

class Google::Protobuf::MethodOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::MethodOptions
end

class Google::Protobuf::OneofDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def name(); end

  def name!(); end

  def name=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::OneofDescriptorProto
end

class Google::Protobuf::ServiceDescriptorProto
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def method(); end

  def method!(); end

  def method=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def options(); end

  def options!(); end

  def options=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::ServiceDescriptorProto
end

class Google::Protobuf::ServiceOptions
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def deprecated(); end

  def deprecated!(); end

  def deprecated=(v); end

  def deprecated?(); end

  def uninterpreted_option(); end

  def uninterpreted_option!(); end

  def uninterpreted_option=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::ServiceOptions
end

class Google::Protobuf::SourceCodeInfo
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def location(); end

  def location!(); end

  def location=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::SourceCodeInfo::Location
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def leading_comments(); end

  def leading_comments!(); end

  def leading_comments=(v); end

  def leading_detached_comments(); end

  def leading_detached_comments!(); end

  def leading_detached_comments=(v); end

  def path(); end

  def path!(); end

  def path=(v); end

  def span(); end

  def span!(); end

  def span=(v); end

  def trailing_comments(); end

  def trailing_comments!(); end

  def trailing_comments=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::SourceCodeInfo::Location
end

class Google::Protobuf::SourceCodeInfo
end

class Google::Protobuf::UninterpretedOption
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def aggregate_value(); end

  def aggregate_value!(); end

  def aggregate_value=(v); end

  def double_value(); end

  def double_value!(); end

  def double_value=(v); end

  def identifier_value(); end

  def identifier_value!(); end

  def identifier_value=(v); end

  def name(); end

  def name!(); end

  def name=(v); end

  def negative_int_value(); end

  def negative_int_value!(); end

  def negative_int_value=(v); end

  def positive_int_value(); end

  def positive_int_value!(); end

  def positive_int_value=(v); end

  def string_value(); end

  def string_value!(); end

  def string_value=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::UninterpretedOption::NamePart
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def is_extension(); end

  def is_extension!(); end

  def is_extension=(v); end

  def is_extension?(); end

  def name_part(); end

  def name_part!(); end

  def name_part=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Google::Protobuf::UninterpretedOption::NamePart
end

class Google::Protobuf::UninterpretedOption
end

module Google::Protobuf
  extend ::Protobuf::Optionable::ClassMethods
  def self.optionable_descriptor_class(); end
end

module Google
end

module Guard::Deprecated::Dsl
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Dsl::ClassMethods
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Evaluator
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  REEVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Guard::ClassMethods
  ADD_GROUP = ::T.let(nil, ::T.untyped)
  ADD_GUARD = ::T.let(nil, ::T.untyped)
  ADD_PLUGIN = ::T.let(nil, ::T.untyped)
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  EVALUATOR = ::T.let(nil, ::T.untyped)
  GET_GUARD_CLASS = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  GROUPS = ::T.let(nil, ::T.untyped)
  GUARDS = ::T.let(nil, ::T.untyped)
  GUARD_GEM_NAMES = ::T.let(nil, ::T.untyped)
  LISTENER_ASSIGN = ::T.let(nil, ::T.untyped)
  LOCATE_GUARD = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PLUGIN = ::T.let(nil, ::T.untyped)
  PLUGINS = ::T.let(nil, ::T.untyped)
  RESET_EVALUATOR = ::T.let(nil, ::T.untyped)
  RUNNER = ::T.let(nil, ::T.untyped)
  RUNNING = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_ASSIGN = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Watcher::ClassMethods
  MATCH_GUARDFILE = ::T.let(nil, ::T.untyped)
end

class Guard::Dsl
  WARN_INVALID_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  WARN_INVALID_LOG_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::Guardfile::Evaluator
  DEFAULT_GUARDFILES = ::T.let(nil, ::T.untyped)
  ERROR_NO_GUARDFILE = ::T.let(nil, ::T.untyped)
  ERROR_NO_PLUGINS = ::T.let(nil, ::T.untyped)
end

class Guard::Internals::Groups
  DEFAULT_GROUPS = ::T.let(nil, ::T.untyped)
end

class Guard::Internals::Session
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::Notifier
  DEPRECATED_IMPLICIT_CONNECT = ::T.let(nil, ::T.untyped)
end

class Guard::Plugin
  TEMPLATE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Guard::PluginUtil
  ERROR_NO_GUARD_OR_CLASS = ::T.let(nil, ::T.untyped)
  INFO_ADDED_GUARD_TO_GUARDFILE = ::T.let(nil, ::T.untyped)
end

class Guard::Runner
  ADDITION_TASKS = ::T.let(nil, ::T.untyped)
  MODIFICATION_TASKS = ::T.let(nil, ::T.untyped)
  PLUGIN_FAILED = ::T.let(nil, ::T.untyped)
  REMOVAL_TASKS = ::T.let(nil, ::T.untyped)
end

module Guard::UI::Colors
  ANSI_ESCAPE_BGBLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGBLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGCYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGGREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGMAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGRED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGWHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGYELLOW = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BRIGHT = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_CYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_GREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_MAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_RED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_WHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_YELLOW = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEPRECATED_OPTS = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Logger::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Guard
  extend ::Guard::Internals::Helpers
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def assert_valid_keys(*valid_keys); end

  def deconstruct_keys(_); end

  def deep_merge!(other_hash, &block); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def nested_under_indifferent_access(); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice!(*keys); end

  def to_options!(); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end

  def with_indifferent_access(); end
end

class Hash
  def self.ruby2_keywords_hash(_); end

  def self.ruby2_keywords_hash?(_); end

  def self.try_convert(_); end
end

class HighLine
  VERSION = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles
  BASIC_COLORS = ::T.let(nil, ::T.untyped)
  BLACK = ::T.let(nil, ::T.untyped)
  BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BLINK = ::T.let(nil, ::T.untyped)
  BLINK_STYLE = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  BOLD_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_RED = ::T.let(nil, ::T.untyped)
  BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CLEAR_STYLE = ::T.let(nil, ::T.untyped)
  COLORS = ::T.let(nil, ::T.untyped)
  COLOR_LIST = ::T.let(nil, ::T.untyped)
  CONCEALED = ::T.let(nil, ::T.untyped)
  CONCEALED_STYLE = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  CYAN_STYLE = ::T.let(nil, ::T.untyped)
  DARK = ::T.let(nil, ::T.untyped)
  DARK_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_CHAR = ::T.let(nil, ::T.untyped)
  ERASE_CHAR_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_LINE = ::T.let(nil, ::T.untyped)
  ERASE_LINE_STYLE = ::T.let(nil, ::T.untyped)
  GRAY = ::T.let(nil, ::T.untyped)
  GRAY_STYLE = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  GREEN_STYLE = ::T.let(nil, ::T.untyped)
  GREY = ::T.let(nil, ::T.untyped)
  GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREY = ::T.let(nil, ::T.untyped)
  LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_RED = ::T.let(nil, ::T.untyped)
  LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GRAY = ::T.let(nil, ::T.untyped)
  ON_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREY = ::T.let(nil, ::T.untyped)
  ON_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_NONE = ::T.let(nil, ::T.untyped)
  ON_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  ON_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RED_STYLE = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  RESET_STYLE = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  REVERSE_STYLE = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
  STYLE_LIST = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  UNDERLINE_STYLE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNDERSCORE_STYLE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  WHITE_STYLE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
  YELLOW_STYLE = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles::ClassMethods
  RGB_COLOR_PATTERN = ::T.let(nil, ::T.untyped)
end

class HighLine::SampleColorScheme
  SAMPLE_SCHEME = ::T.let(nil, ::T.untyped)
end

module HighLine::StringExtensions
  STYLE_METHOD_NAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Event::Loop
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Listener::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Silencer
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Lumberjack
  LINE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::LogFile
  EXTERNAL_ENCODING = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::Writer
  DEFAULT_ADDITIONAL_LINES_TEMPLATE = ::T.let(nil, ::T.untyped)
  DEFAULT_FIRST_LINE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Lumberjack::LogEntry
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  UNIT_OF_WORK_ID = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Rack::RequestId
  REQUEST_ID = ::T.let(nil, ::T.untyped)
end

module Lumberjack::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  SEVERITY_LABELS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

class Lumberjack::TaggedLoggerSupport::Formatter
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Template
  MICROSECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  MILLISECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  PLACEHOLDER_PATTERN = ::T.let(nil, ::T.untyped)
  TEMPLATE_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
end

class MIME::Type
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  VERSION = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Columnar
  LOAD_MUTEX = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Data
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  extend ::Enumerable
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module Middleware
  VERSION = ::T.let(nil, ::T.untyped)
end

class Middleware::Runner
  EMPTY_MIDDLEWARE = ::T.let(nil, ::T.untyped)
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Module
  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end

  def deprecate(*method_names); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def method_visibility(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def silence_redefinition_of_method(method); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Module::DelegationError
end

class Module::DelegationError
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiJson
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::OptionsCache
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
end

module Necromancer
  VERSION = ::T.let(nil, ::T.untyped)
end

module Necromancer::BooleanConverters
  FALSE_MATCHER = ::T.let(nil, ::T.untyped)
  TRUE_MATCHER = ::T.let(nil, ::T.untyped)
end

class Necromancer::Conversions
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Necromancer::NumericConverters
  FLOAT_MATCHER = ::T.let(nil, ::T.untyped)
  INTEGER_MATCHER = ::T.let(nil, ::T.untyped)
end

module Necromancer::RangeConverters
  DIGIT_MATCHER = ::T.let(nil, ::T.untyped)
  LETTER_MATCHER = ::T.let(nil, ::T.untyped)
  SINGLE_DIGIT_MATCHER = ::T.let(nil, ::T.untyped)
end

module Nenv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

module Notiffany
  VERSION = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier
  NOTIFICATIONS_DISABLED = ::T.let(nil, ::T.untyped)
  ONLY_NOTIFY = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
  USING_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Base
  ERROR_ADD_GEM_AND_RUN_BUNDLE = ::T.let(nil, ::T.untyped)
  HOSTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Detected
  NO_SUPPORTED_NOTIFIERS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Emacs
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_ELISP_ERB = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::File
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::GNTP
  CLIENT_DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Growl
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INSTALL_GROWLNOTIFY = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Libnotify
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Notifu
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::NotifySend
  DEFAULTS = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalNotifier
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ONLY_OSX10 = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalTitle
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ANCIENT_TMUX = ::T.let(nil, ::T.untyped)
  ERROR_NOT_INSIDE_TMUX = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux::Client
  CLIENT = ::T.let(nil, ::T.untyped)
end

class Numeric
  def value(*args, &block); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::Tryable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RAKEVERSION = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class PT::CLI
  def accept(story_id=T.unsafe(nil)); end

  def accepted(owner=T.unsafe(nil)); end

  def add_label(story_id=T.unsafe(nil)); end

  def assign(story_id=T.unsafe(nil)); end

  def backlog(); end

  def bug(owner=T.unsafe(nil)); end

  def chore(owner=T.unsafe(nil)); end

  def comment(story_id=T.unsafe(nil)); end

  def current(); end

  def deliver(story_id=T.unsafe(nil)); end

  def delivered(owner=T.unsafe(nil)); end

  def done(story_id=T.unsafe(nil)); end

  def edit(story_id=T.unsafe(nil)); end

  def estimate(story_id=T.unsafe(nil)); end

  def feature(owner=T.unsafe(nil)); end

  def finish(story_id=T.unsafe(nil)); end

  def finished(owner=T.unsafe(nil)); end

  def open(story_id=T.unsafe(nil)); end

  def reject(story_id=T.unsafe(nil)); end

  def rejected(owner=T.unsafe(nil)); end

  def release(owner=T.unsafe(nil)); end

  def show(story_id=T.unsafe(nil)); end

  def start(story_id=T.unsafe(nil)); end

  def started(owner=T.unsafe(nil)); end

  def tasks(story_id=T.unsafe(nil)); end

  def unscheduled(owner=T.unsafe(nil)); end

  def unstart(story_id=T.unsafe(nil)); end
end

module Paint
  ANSI_COLORS = ::T.let(nil, ::T.untyped)
  ANSI_COLORS_BACKGROUND = ::T.let(nil, ::T.untyped)
  ANSI_COLORS_FOREGROUND = ::T.let(nil, ::T.untyped)
  ANSI_EFFECTS = ::T.let(nil, ::T.untyped)
  NOTHING = ::T.let(nil, ::T.untyped)
  RGB_COLORS = ::T.let(nil, ::T.untyped)
  RGB_COLORS_ANSI = ::T.let(nil, ::T.untyped)
  RGB_COLORS_ANSI_BRIGHT = ::T.let(nil, ::T.untyped)
  RGB_COLORS_INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  TRUE_COLOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parlour::ConflictResolver
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Conversion::Converter
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging::Tree
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Generator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Options
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::ParseError
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Plugin
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::StructProp
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbsGenerator::Block
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbsGenerator::MethodSignature
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbsGenerator::Parameter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::TypeLoader
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypeParser::NodePath
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypeParser
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypedObject
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Types::Proc::Parameter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Types::Type
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby27

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby27
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

module Pastel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Pastel::ANSI
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Pastel::Color
  ALIASES = ::T.let(nil, ::T.untyped)
  ANSI_COLOR_REGEXP = ::T.let(nil, ::T.untyped)
end

class Pastel::ColorParser
  CSI = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

module Protobuf
end

class Protobuf::Decoder
end

class Protobuf::Decoder
  def self.decode_each_field(stream); end
end

class Protobuf::Deprecation
  def define_deprecated_methods(target_module, method_hash); end
end

class Protobuf::Deprecation
  def self.define_deprecated_methods(*_, &_1); end
end

class Protobuf::DeprecationBase
  def deprecate_methods(*args); end
end

class Protobuf::DeprecationBase
  def self.deprecation_warning(*_, &_1); end
end

class Protobuf::DuplicateFieldNameError
end

class Protobuf::DuplicateFieldNameError
end

class Protobuf::Encoder
end

class Protobuf::Encoder
  def self.encode(message, stream); end
end

class Protobuf::Enum
  include ::Protobuf::Optionable
  def ==(other); end

  def eql?(other); end

  def initialize(parent_class, name, tag); end

  def inspect(); end

  def name(); end

  def parent_class(); end

  def tag(); end

  def to_hash_value(); end

  def to_i(); end

  def to_int(); end

  def to_json(*_); end

  def to_json_hash_value(); end

  def to_s(format=T.unsafe(nil)); end

  def try(*args, &block); end

  def value(*args, &block); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Protobuf::Enum
  extend ::Protobuf::Optionable::ClassMethods
  def self.aliases_allowed?(); end

  def self.all_tags(); end

  def self.define(name, tag); end

  def self.enum_by_value(*args, &block); end

  def self.enum_for_name(name); end

  def self.enum_for_tag(tag); end

  def self.enum_for_tag_integer(tag); end

  def self.enums(); end

  def self.enums_for_tag(tag); end

  def self.fetch(candidate); end

  def self.get_name_by_tag(*args, &block); end

  def self.mapped_enums(); end

  def self.name_by_value(*args, &block); end

  def self.name_for_tag(tag); end

  def self.optionable_descriptor_class(); end

  def self.valid_tag?(tag); end

  def self.value_by_name(*args, &block); end

  def self.values(*args, &block); end
end

class Protobuf::Error
end

class Protobuf::Error
end

module Protobuf::Field
  PRIMITIVE_FIELD_MAP = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::BaseField
  include ::Protobuf::Logging
  include ::Protobuf::Optionable::ClassMethods
  def acceptable?(_value); end

  def coerce!(value); end

  def decode(_bytes); end

  def default(); end

  def default_value(); end

  def define_encode_to_stream!(); end

  def define_field_and_present_predicate!(); end

  def define_field_predicate!(); end

  def define_set_field!(); end

  def define_set_method!(); end

  def define_to_message_hash!(); end

  def define_value_from_values!(); end

  def define_value_from_values_for_serialization!(); end

  def deprecated?(); end

  def encode(_value); end

  def encode_to_stream(value, stream); end

  def enum?(); end

  def extension?(); end

  def field?(values); end

  def field_and_present?(values); end

  def fully_qualified_name(); end

  def fully_qualified_name_only!(); end

  def initialize(message_class, rule, type_class, fully_qualified_name, tag, simple_name, options); end

  def map?(); end

  def message?(); end

  def message_class(); end

  def name(); end

  def optionable_descriptor_class(); end

  def optional?(); end

  def options(); end

  def packed?(); end

  def repeated?(); end

  def repeated_message?(); end

  def required?(); end

  def rule(); end

  def set(message_instance, bytes); end

  def set_default_value!(); end

  def set_field(values, value, ignore_nil_for_repeated, message_instance); end

  def set_map!(); end

  def set_repeated_message!(); end

  def tag(); end

  def tag_encoded(); end

  def to_message_hash(values, result); end

  def to_message_hash_with_string_key(values, result); end

  def type(*args, &block); end

  def type_class(); end

  def value_from_values(values); end

  def value_from_values_for_serialization(values); end

  def wire_type(); end
  PACKED_TYPES = ::T.let(nil, ::T.untyped)
end

Protobuf::Field::BaseField::OBJECT_MODULE = Protobuf::Field::BaseFieldObjectDefinitions

class Protobuf::Field::BaseField
  def self.default(); end
end

module Protobuf::Field::BaseFieldObjectDefinitions
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseEncodeToStream
  def call(value, stream); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseEncodeToStream
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldAndPresentPredicate
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldAndPresentPredicate
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldPredicate
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldPredicate
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldValueFromValues
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldValueFromValues
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldValueFromValuesForSerialization
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseFieldValueFromValuesForSerialization
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseSetField
  def call(values, value, _ignore_nil_for_repeated, _message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseSetMethod
  def call(message_instance, bytes); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseSetMethod
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseToMessageHash
  def call(values, result); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseToMessageHash
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseToMessageHashWithStringKey
  def call(values, result); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BaseToMessageHashWithStringKey
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldAndPresentPredicate
  def call(values); end

  def initialize(selph); end
  BOOL_VALUES = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldAndPresentPredicate
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldValueFromValues
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldValueFromValues
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldValueFromValuesForSerialization
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BoolFieldValueFromValuesForSerialization
end

class Protobuf::Field::BaseFieldObjectDefinitions::BytesEncodeToStream
  def call(value, stream); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::BytesEncodeToStream
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapSetField
  def call(values, value, _ignore_nil_for_repeated, _message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapSetMethod
  def call(message_instance, bytes); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapSetMethod
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapValueFromValues
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapValueFromValues
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapValueFromValuesForSerialization
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::MapValueFromValuesForSerialization
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldPredicate
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldPredicate
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldValueFromValues
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldValueFromValues
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldValueFromValuesForSerialization
  def call(values); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedFieldValueFromValuesForSerialization
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedNotPackedEncodeToStream
  def call(value, stream); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedNotPackedEncodeToStream
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedNotPackedSetMethod
  def call(message_instance, bytes); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedNotPackedSetMethod
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedPackedEncodeToStream
  def call(value, stream); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedPackedEncodeToStream
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedPackedSetMethod
  def call(message_instance, bytes); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedPackedSetMethod
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedSetField
  def call(values, value, ignore_nil_for_repeated, _message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RepeatedSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredBaseSetField
  def call(values, value, _ignore_nil_for_repeated, message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredBaseSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredMapSetField
  def call(values, value, _ignore_nil_for_repeated, message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredMapSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredRepeatedSetField
  def call(values, value, ignore_nil_for_repeated, message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredRepeatedSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredStringSetField
  def call(values, value, _ignore_nil_for_repeated, message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::RequiredStringSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::StringEncodeToStream
  def call(value, stream); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::StringEncodeToStream
end

class Protobuf::Field::BaseFieldObjectDefinitions::StringSetField
  def call(values, value, _ignore_nil_for_repeated, _message_instance); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::StringSetField
end

class Protobuf::Field::BaseFieldObjectDefinitions::ToHashValueToMessageHash
  def call(values, result); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::ToHashValueToMessageHash
end

class Protobuf::Field::BaseFieldObjectDefinitions::ToHashValueToMessageHashWithStringKey
  def call(values, result); end

  def initialize(selph); end
end

class Protobuf::Field::BaseFieldObjectDefinitions::ToHashValueToMessageHashWithStringKey
end

module Protobuf::Field::BaseFieldObjectDefinitions
end

class Protobuf::Field::BoolField
  ACCEPTABLES = ::T.let(nil, ::T.untyped)
  FALSE_ENCODE = ::T.let(nil, ::T.untyped)
  FALSE_STRING = ::T.let(nil, ::T.untyped)
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  ONE = ::T.let(nil, ::T.untyped)
  TRUE_ENCODE = ::T.let(nil, ::T.untyped)
  TRUE_STRING = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::BoolField
end

class Protobuf::Field::BytesField
  def acceptable?(val); end

  def decode(bytes); end

  def encode(value); end

  def json_encode(value, options=T.unsafe(nil)); end
  BYTES_ENCODING = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::BytesField
end

class Protobuf::Field::DoubleField
end

class Protobuf::Field::DoubleField
end

class Protobuf::Field::EnumField
  def coerce!(value); end

  def json_encode(value, options=T.unsafe(nil)); end
end

class Protobuf::Field::EnumField
end

class Protobuf::Field::FieldArray
  def <<(val); end

  def []=(nth, val); end

  def field(); end

  def initialize(field); end

  def push(val); end

  def replace(val); end

  def to_hash_value(); end

  def to_json_hash_value(options=T.unsafe(nil)); end

  def unshift(val); end
end

class Protobuf::Field::FieldArray
end

class Protobuf::Field::FieldHash
  def []=(key, val); end

  def field(); end

  def initialize(field); end

  def key_field(); end

  def merge!(other); end

  def replace(val); end

  def store(key, val); end

  def to_hash_value(); end

  def to_json_hash_value(options=T.unsafe(nil)); end

  def update(other); end

  def value_field(); end
end

class Protobuf::Field::FieldHash
end

class Protobuf::Field::Fixed32Field
  def decode(bytes); end
end

class Protobuf::Field::Fixed32Field
end

class Protobuf::Field::Fixed64Field
  def decode(bytes); end
end

class Protobuf::Field::Fixed64Field
end

class Protobuf::Field::FloatField
  def acceptable?(val); end

  def coerce!(val); end

  def decode(bytes); end

  def encode(value); end
end

class Protobuf::Field::FloatField
end

class Protobuf::Field::Int32Field
end

class Protobuf::Field::Int32Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::Int64Field
  def json_encode(value, options=T.unsafe(nil)); end
end

class Protobuf::Field::Int64Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::IntegerField
end

class Protobuf::Field::IntegerField
end

class Protobuf::Field::MessageField
  def acceptable?(val); end

  def decode(bytes); end

  def encode(value); end
end

class Protobuf::Field::MessageField
end

class Protobuf::Field::Sfixed32Field
  def decode(bytes); end
end

class Protobuf::Field::Sfixed32Field
end

class Protobuf::Field::Sfixed64Field
  def decode(bytes); end
end

class Protobuf::Field::Sfixed64Field
end

class Protobuf::Field::SignedIntegerField
end

class Protobuf::Field::SignedIntegerField
end

class Protobuf::Field::Sint32Field
end

class Protobuf::Field::Sint32Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::Sint64Field
  def json_encode(value, options=T.unsafe(nil)); end
end

class Protobuf::Field::Sint64Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::StringField
  ENCODING = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::StringField
end

class Protobuf::Field::Uint32Field
end

class Protobuf::Field::Uint32Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::Uint64Field
  def json_encode(value, options=T.unsafe(nil)); end
end

class Protobuf::Field::Uint64Field
  def self.max(); end

  def self.min(); end
end

class Protobuf::Field::VarintField
  def acceptable?(val); end

  def coerce!(val); end

  def decode(value); end

  def encode(value); end
  INT32_MAX = ::T.let(nil, ::T.untyped)
  INT32_MIN = ::T.let(nil, ::T.untyped)
  INT64_MAX = ::T.let(nil, ::T.untyped)
  INT64_MIN = ::T.let(nil, ::T.untyped)
  UINT32_MAX = ::T.let(nil, ::T.untyped)
  UINT64_MAX = ::T.let(nil, ::T.untyped)
end

class Protobuf::Field::VarintField
  def self.encode(value); end
end

module Protobuf::Field
  def self.build(message_class, rule, type, name, tag, simple_name, options=T.unsafe(nil)); end

  def self.field_class(type); end

  def self.field_type(type); end
end

class Protobuf::FieldDeprecation
  def deprecate_method(target_module, method_name); end
end

class Protobuf::FieldDeprecation
  def self.deprecate_method(*_, &_1); end

  def self.deprecated_method_warning(*_, &_1); end
end

class Protobuf::FieldNotDefinedError
end

class Protobuf::FieldNotDefinedError
end

class Protobuf::InvalidWireType
end

class Protobuf::InvalidWireType
end

module Protobuf::Logging
  def log_exception(ex); end

  def log_signature(); end

  def logger(); end

  def sign_message(message); end
end

module Protobuf::Logging
  def self.initialize_logger(log_target=T.unsafe(nil), log_level=T.unsafe(nil)); end

  def self.logger(); end

  def self.logger=(logger); end
end

class Protobuf::Message
  include ::Protobuf::Message::Serialization
  include ::Protobuf::Optionable
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def clear!(); end

  def clone(); end

  def each_field(); end

  def each_field_for_serialization(); end

  def field?(name); end

  def has_field?(*args, &block); end

  def initialize(fields=T.unsafe(nil)); end

  def respond_to_and_has?(name); end

  def respond_to_and_has_and_present?(key); end

  def respond_to_and_has_present?(key); end

  def respond_to_has?(name); end

  def respond_to_has_and_present?(key); end

  def respond_to_has_present?(key); end

  def responds_to_and_has?(name); end

  def responds_to_and_has_and_present?(key); end

  def responds_to_and_has_present?(key); end

  def responds_to_has?(name); end

  def responds_to_has_present?(key); end

  def set_field(name, value, ignore_nil_for_repeated, field=T.unsafe(nil)); end

  def to_hash(); end

  def to_hash_value(); end

  def to_hash_with_string_keys(); end

  def to_json_hash(options=T.unsafe(nil)); end

  def to_json_hash_value(options=T.unsafe(nil)); end

  def to_proto(); end

  def to_proto_hash(); end
end

module Protobuf::Message::Serialization
  def bytes(); end

  def decode(bytes); end

  def decode_from(stream); end

  def deserialize(bytes); end

  def deserialize_from(stream); end

  def encode(); end

  def encode_to(stream); end

  def parse_from(stream); end

  def parse_from_string(bytes); end

  def serialize(); end

  def serialize_to(stream); end

  def serialize_to_string(); end

  def to_s(); end
end

module Protobuf::Message::Serialization
  def self.included(other); end
end

class Protobuf::Message
  extend ::Protobuf::Optionable::ClassMethods
  def self.from_json(json); end

  def self.get_ext_field_by_name(*args, &block); end

  def self.get_ext_field_by_tag(*args, &block); end

  def self.get_field_by_name(*args, &block); end

  def self.get_field_by_tag(*args, &block); end

  def self.normalize_json(ob); end

  def self.optionable_descriptor_class(); end

  def self.to_json(); end
end

class Protobuf::NotInitializedError
end

class Protobuf::NotInitializedError
end

module Protobuf::Optionable
  def get_option(name); end

  def get_option!(name); end
end

module Protobuf::Optionable::ClassMethods
  def get_option(name); end

  def get_option!(name); end
end

module Protobuf::Optionable::ClassMethods
end

module Protobuf::Optionable
  def self.inject(base_class, extend_class=T.unsafe(nil), &block); end
end

module Protobuf::Rpc
end

class Protobuf::Rpc::BadRequestData
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::BadRequestData
end

class Protobuf::Rpc::BadRequestProto
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::BadRequestProto
end

class Protobuf::Rpc::BadResponseProto
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::BadResponseProto
end

class Protobuf::Rpc::Buffer
  def <<(data); end

  def data(); end

  def data=(data); end

  def flushed?(); end

  def get_data_size(); end

  def initialize(mode=T.unsafe(nil)); end

  def mode(); end

  def mode=(mode); end

  def reading?(); end

  def set_data(data); end

  def size(); end

  def size=(size); end

  def write(force_mode=T.unsafe(nil)); end

  def writing?(); end
  MODES = ::T.let(nil, ::T.untyped)
  SIZE_REGEX = ::T.let(nil, ::T.untyped)
end

class Protobuf::Rpc::Buffer
end

class Protobuf::Rpc::Client
  include ::Protobuf::Logging
  def complete_cb(*args, &block); end

  def connector(); end

  def failure_cb(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def method_missing(method_name, *params); end

  def on_complete(&complete_cb); end

  def on_complete=(callable); end

  def on_failure(&failure_cb); end

  def on_failure=(callable); end

  def on_success(&success_cb); end

  def on_success=(callable); end

  def options(*args, &block); end

  def send_request(*args, &block); end

  def success_cb(*args, &block); end
end

class Protobuf::Rpc::Client
  extend ::Forwardable
end

Protobuf::Rpc::ClientError = Struct::ClientError

module Protobuf::Rpc::Connectors
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Protobuf::Rpc::Connectors::Base
  include ::Protobuf::Logging
  def any_callbacks?(); end

  def close_connection(); end

  def complete(); end

  def complete_cb(); end

  def complete_cb=(complete_cb); end

  def data_callback(data); end

  def error(); end

  def failure(code, message); end

  def failure_cb(); end

  def failure_cb=(failure_cb); end

  def first_alive_load_balance?(); end

  def initialize(options); end

  def initialize_stats(); end

  def options(); end

  def parse_response(); end

  def ping_port(); end

  def ping_port_enabled?(); end

  def request_bytes(); end

  def request_caller(); end

  def request_fields(); end

  def send_request(); end

  def setup_connection(); end

  def stats(); end

  def stats=(stats); end

  def succeed(response); end

  def success_cb(); end

  def success_cb=(success_cb); end

  def timeout(); end

  def timeout_wrap(&block); end

  def validate_request_type!(); end

  def verify_callbacks(); end

  def verify_options!(); end
end

class Protobuf::Rpc::Connectors::Base
end

class Protobuf::Rpc::Connectors::Socket
end

class Protobuf::Rpc::Connectors::Socket
end

module Protobuf::Rpc::Connectors
end

class Protobuf::Rpc::Env
  def client_host(); end

  def client_host=(value); end

  def client_host?(); end

  def encoded_request(); end

  def encoded_request=(value); end

  def encoded_request?(); end

  def encoded_response(); end

  def encoded_response=(value); end

  def encoded_response?(); end

  def initialize(options=T.unsafe(nil)); end

  def log_signature(); end

  def log_signature=(value); end

  def log_signature?(); end

  def method_name(); end

  def method_name=(value); end

  def method_name?(); end

  def request(); end

  def request=(value); end

  def request?(); end

  def request_type(); end

  def request_type=(value); end

  def request_type?(); end

  def request_wrapper(); end

  def request_wrapper=(value); end

  def request_wrapper?(); end

  def response(); end

  def response=(value); end

  def response?(); end

  def response_type(); end

  def response_type=(value); end

  def response_type?(); end

  def rpc_method(); end

  def rpc_method=(value); end

  def rpc_method?(); end

  def rpc_service(); end

  def rpc_service=(value); end

  def rpc_service?(); end

  def server(); end

  def server=(value); end

  def server?(); end

  def service_name(); end

  def service_name=(value); end

  def service_name?(); end

  def worker_id(); end

  def worker_id=(value); end

  def worker_id?(); end
end

class Protobuf::Rpc::Env
  def self.hash_accessor(*names); end
end

class Protobuf::Rpc::IOError
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::IOError
end

class Protobuf::Rpc::InvalidRequestProto
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::InvalidRequestProto
end

class Protobuf::Rpc::MethodNotFound
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::MethodNotFound
end

module Protobuf::Rpc::Middleware
end

class Protobuf::Rpc::Middleware::ExceptionHandler
  include ::Protobuf::Logging
  def _call(env); end

  def app(); end

  def call(env); end

  def initialize(app); end
end

class Protobuf::Rpc::Middleware::ExceptionHandler
end

class Protobuf::Rpc::Middleware::Logger
  def _call(env); end

  def call(env); end

  def initialize(app); end
end

class Protobuf::Rpc::Middleware::Logger::Instrumenter
  def env(); end

  def flush(env); end

  def start(); end

  def stop(); end

  def to_s(env); end
end

class Protobuf::Rpc::Middleware::Logger::Instrumenter
end

class Protobuf::Rpc::Middleware::Logger
end

class Protobuf::Rpc::Middleware::RequestDecoder
  include ::Protobuf::Logging
  def _call(env); end

  def app(); end

  def call(env); end

  def env(); end

  def initialize(app); end
end

class Protobuf::Rpc::Middleware::RequestDecoder
end

class Protobuf::Rpc::Middleware::ResponseEncoder
  include ::Protobuf::Logging
  def _call(env); end

  def app(); end

  def call(env); end

  def env(); end

  def initialize(app); end
end

class Protobuf::Rpc::Middleware::ResponseEncoder
end

class Protobuf::Rpc::Middleware::Runner
end

class Protobuf::Rpc::Middleware::Runner
end

module Protobuf::Rpc::Middleware
end

class Protobuf::Rpc::PbError
  def encode(); end

  def error_type(); end

  def initialize(message=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def to_response(); end
end

class Protobuf::Rpc::PbError
end

class Protobuf::Rpc::RpcError
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::RpcError
end

class Protobuf::Rpc::RpcFailed
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::RpcFailed
end

class Protobuf::Rpc::RpcMethod
  include ::Protobuf::Optionable::ClassMethods
  def initialize(method, request_type, response_type, &options_block); end

  def method(); end

  def optionable_descriptor_class(); end

  def request_type(); end

  def response_type(); end
end

class Protobuf::Rpc::RpcMethod
end

module Protobuf::Rpc::Server
  def gc_pause(); end

  def handle_request(request_data, env_data=T.unsafe(nil)); end

  def log_signature(); end
end

module Protobuf::Rpc::Server
end

class Protobuf::Rpc::Service
  include ::Protobuf::Logging
  include ::Protobuf::Rpc::ServiceFilters
  include ::Protobuf::Rpc::ServiceFilters::InstanceMethods
  include ::Protobuf::Optionable
  def call(method_name); end

  def env(); end

  def initialize(env); end

  def request(); end

  def response(); end

  def rpc_method?(name); end

  def rpcs(); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Protobuf::Rpc::Service
  extend ::Protobuf::Rpc::ServiceFilters::ClassMethods
  extend ::Protobuf::Optionable::ClassMethods
  def self.client(options=T.unsafe(nil)); end

  def self.configure(config=T.unsafe(nil)); end

  def self.host(); end

  def self.host=(host); end

  def self.implemented_services(); end

  def self.located_at(location); end

  def self.optionable_descriptor_class(); end

  def self.port(); end

  def self.port=(port); end

  def self.rpc(method, request_type, response_type, &options_block); end

  def self.rpc_method?(name); end

  def self.rpcs(); end
end

class Protobuf::Rpc::ServiceDispatcher
  include ::Protobuf::Logging
  def _call(env); end

  def call(env); end

  def env(); end

  def initialize(_app); end

  def rpc_service(); end
end

class Protobuf::Rpc::ServiceDispatcher
end

module Protobuf::Rpc::ServiceFilters
end

module Protobuf::Rpc::ServiceFilters::ClassMethods
  def after_action(*args); end

  def after_filter(*args); end

  def around_action(*args); end

  def around_filter(*args); end

  def before_action(*args); end

  def before_filter(*args); end

  def filters(); end

  def rescue_filters(); end

  def rescue_from(*ex_klasses, &block); end
end

module Protobuf::Rpc::ServiceFilters::ClassMethods
end

module Protobuf::Rpc::ServiceFilters::InstanceMethods
end

module Protobuf::Rpc::ServiceFilters::InstanceMethods
end

module Protobuf::Rpc::ServiceFilters
  def self.included(other); end
end

class Protobuf::Rpc::ServiceNotFound
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::ServiceNotFound
end

module Protobuf::Rpc::Socket
end

class Protobuf::Rpc::Socket::Server
  include ::Protobuf::Logging
  def cleanup?(); end

  def cleanup_threads(); end

  def initialize(options); end

  def new_worker(socket); end

  def run(); end

  def running(); end

  def running?(); end

  def stop(); end

  def threads(); end

  def working(); end
  AUTO_COLLECT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Protobuf::Rpc::Socket::Server
end

class Protobuf::Rpc::Socket::Worker
  include ::Protobuf::Rpc::Server
  include ::Protobuf::Logging
  def initialize(sock, &complete_cb); end

  def read_data(); end

  def send_data(data); end

  def socket_writable?(); end
end

class Protobuf::Rpc::Socket::Worker
end

module Protobuf::Rpc::Socket
end

class Protobuf::Rpc::Stat
  def client(); end

  def client=(client); end

  def client?(); end

  def dispatcher(); end

  def dispatcher=(dispatcher); end

  def elapsed_time(); end

  def end_time(); end

  def end_time=(end_time); end

  def initialize(mode=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def mode(); end

  def mode=(mode); end

  def request_size(); end

  def request_size=(request_size); end

  def response_size(); end

  def response_size=(response_size); end

  def rpc(); end

  def server(); end

  def server=(peer); end

  def server?(); end

  def service(); end

  def service=(service); end

  def sizes(); end

  def start(); end

  def start_time(); end

  def start_time=(start_time); end

  def status(); end

  def status=(status); end

  def status_string(); end

  def stop(); end

  def stopped?(); end

  def trace_id(); end
  ERROR_TRANSLATIONS = ::T.let(nil, ::T.untyped)
  MODES = ::T.let(nil, ::T.untyped)
end

class Protobuf::Rpc::Stat
end

class Protobuf::Rpc::UnkownHost
  def initialize(message=T.unsafe(nil)); end
end

class Protobuf::Rpc::UnkownHost
end

module Protobuf::Rpc
  def self.middleware(); end
end

class Protobuf::SerializationError
end

class Protobuf::SerializationError
end

module Protobuf::Socketrpc
  include ::Protobuf::Optionable
end

class Protobuf::Socketrpc::ErrorReason
  BAD_REQUEST_DATA = ::T.let(nil, ::T.untyped)
  BAD_REQUEST_PROTO = ::T.let(nil, ::T.untyped)
  BAD_RESPONSE_PROTO = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST_PROTO = ::T.let(nil, ::T.untyped)
  IO_ERROR = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  RPC_ERROR = ::T.let(nil, ::T.untyped)
  RPC_FAILED = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  SERVICE_NOT_FOUND = ::T.let(nil, ::T.untyped)
  UNKNOWN_HOST = ::T.let(nil, ::T.untyped)
end

class Protobuf::Socketrpc::ErrorReason
end

class Protobuf::Socketrpc::Header
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def key(); end

  def key!(); end

  def key=(v); end

  def value(); end

  def value!(); end

  def value=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Protobuf::Socketrpc::Header
end

class Protobuf::Socketrpc::Request
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def caller(); end

  def caller!(); end

  def caller=(v); end

  def headers(); end

  def headers!(); end

  def headers=(v); end

  def method_name(); end

  def method_name!(); end

  def method_name=(v); end

  def request_proto(); end

  def request_proto!(); end

  def request_proto=(v); end

  def service_name(); end

  def service_name!(); end

  def service_name=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Protobuf::Socketrpc::Request
end

class Protobuf::Socketrpc::Response
  def _protobuf_message_field(); end

  def _protobuf_message_unset_required_field_tags(); end

  def callback(); end

  def callback!(); end

  def callback=(v); end

  def callback?(); end

  def error(); end

  def error!(); end

  def error=(v); end

  def error_reason(); end

  def error_reason!(); end

  def error_reason=(v); end

  def response_proto(); end

  def response_proto!(); end

  def response_proto=(v); end

  def server(); end

  def server!(); end

  def server=(v); end
  PROTOBUF_MESSAGE_GET_FIELD = ::T.let(nil, ::T.untyped)
  PROTOBUF_MESSAGE_REQUIRED_FIELD_TAGS = ::T.let(nil, ::T.untyped)
end

class Protobuf::Socketrpc::Response
end

module Protobuf::Socketrpc
  extend ::Protobuf::Optionable::ClassMethods
  def self.optionable_descriptor_class(); end
end

class Protobuf::TagCollisionError
end

class Protobuf::TagCollisionError
end

class Protobuf::Varint
end

class Protobuf::Varint
  extend ::Protobuf::VarintPure
end

module Protobuf::VarintPure
  def cached_varint(value); end

  def decode(stream); end

  def encode(value, use_cache=T.unsafe(nil)); end
  CACHE_LIMIT = ::T.let(nil, ::T.untyped)
end

module Protobuf::VarintPure
end

module Protobuf::WireType
  END_GROUP = ::T.let(nil, ::T.untyped)
  FIXED32 = ::T.let(nil, ::T.untyped)
  FIXED64 = ::T.let(nil, ::T.untyped)
  LENGTH_DELIMITED = ::T.let(nil, ::T.untyped)
  START_GROUP = ::T.let(nil, ::T.untyped)
  VARINT = ::T.let(nil, ::T.untyped)
end

module Protobuf::WireType
end

module Protobuf
  def self.after_server_bind(&block); end

  def self.before_server_bind(&block); end

  def self.client_host(); end

  def self.client_host=(client_host); end

  def self.connector_type_class(); end

  def self.connector_type_class=(type_class); end

  def self.deprecator(); end

  def self.field_deprecator(); end

  def self.gc_pause_server_request=(value); end

  def self.gc_pause_server_request?(); end

  def self.ignore_unknown_fields=(value); end

  def self.ignore_unknown_fields?(); end

  def self.print_deprecation_warnings=(value); end

  def self.print_deprecation_warnings?(); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extentions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rake::AltSystem
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
  FIXNUM_MAX = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Representable
  As = ::T.let(nil, ::T.untyped)
  AssignAs = ::T.let(nil, ::T.untyped)
  AssignFragment = ::T.let(nil, ::T.untyped)
  AssignName = ::T.let(nil, ::T.untyped)
  Decorate = ::T.let(nil, ::T.untyped)
  Default = ::T.let(nil, ::T.untyped)
  Deserialize = ::T.let(nil, ::T.untyped)
  Deserializer = ::T.let(nil, ::T.untyped)
  FindOrInstantiate = ::T.let(nil, ::T.untyped)
  GetValue = ::T.let(nil, ::T.untyped)
  Getter = ::T.let(nil, ::T.untyped)
  If = ::T.let(nil, ::T.untyped)
  OptionsForNested = ::T.let(nil, ::T.untyped)
  OverwriteOnNil = ::T.let(nil, ::T.untyped)
  ParseFilter = ::T.let(nil, ::T.untyped)
  Prepare = ::T.let(nil, ::T.untyped)
  ReadFragment = ::T.let(nil, ::T.untyped)
  Reader = ::T.let(nil, ::T.untyped)
  RenderDefault = ::T.let(nil, ::T.untyped)
  RenderFilter = ::T.let(nil, ::T.untyped)
  Serialize = ::T.let(nil, ::T.untyped)
  Serializer = ::T.let(nil, ::T.untyped)
  SetValue = ::T.let(nil, ::T.untyped)
  Setter = ::T.let(nil, ::T.untyped)
  SkipParse = ::T.let(nil, ::T.untyped)
  SkipRender = ::T.let(nil, ::T.untyped)
  Stop = ::T.let(nil, ::T.untyped)
  StopOnExcluded = ::T.let(nil, ::T.untyped)
  StopOnNil = ::T.let(nil, ::T.untyped)
  StopOnNotFound = ::T.let(nil, ::T.untyped)
  StopOnSkipable = ::T.let(nil, ::T.untyped)
  WriteFragment = ::T.let(nil, ::T.untyped)
  Writer = ::T.let(nil, ::T.untyped)
end

module Representable::CreateObject
  Class = ::T.let(nil, ::T.untyped)
  Instance = ::T.let(nil, ::T.untyped)
  Populator = ::T.let(nil, ::T.untyped)
end

module Representable::Declarative
  NestedBuilder = ::T.let(nil, ::T.untyped)
end

class Representable::Decorator
  include ::Representable
  include ::Representable::Cached
  def decorated(); end

  def initialize(represented); end
end

class Representable::Decorator
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Cached::BuildDefinition
  extend ::Uber::InheritableAttr
  def self.clone(); end

  def self.map(); end

  def self.map=(v); end
end

module Representable::Hash::AllowSymbols
end

module Representable::Hash::AllowSymbols
end

module Representable::Hash::Collection
  include ::Representable::Hash
  include ::Representable
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, options, format); end
end

module Representable::Hash::Collection::ClassMethods
  def items(options=T.unsafe(nil), &block); end
end

module Representable::Hash::Collection::ClassMethods
end

module Representable::Hash::Collection
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  def self.included(base); end
end

module Representable::HashMethods
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, options, format); end
end

module Representable::HashMethods
end

module Representable::JSON::Collection
  include ::Representable::JSON
  include ::Representable::Hash
  include ::Representable
end

module Representable::JSON::Collection
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::JSON::ClassMethods
  def self.included(base); end
end

module Representable::JSON
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
end

module Representable::Object
  def from_object(data, options=T.unsafe(nil), binding_builder=T.unsafe(nil)); end

  def to_object(options=T.unsafe(nil), binding_builder=T.unsafe(nil)); end
end

class Representable::Object::Binding
  def deserialize_method(); end

  def read(hash, as); end

  def serialize_method(); end

  def write(hash, fragment, as); end
end

class Representable::Object::Binding::Collection
  include ::Representable::Binding::Collection
end

class Representable::Object::Binding::Collection
end

class Representable::Object::Binding
  def self.build_for(definition); end
end

module Representable::Object::ClassMethods
  def collection_representer_class(); end
end

module Representable::Object::ClassMethods
end

module Representable::Object
  def self.included(base); end
end

class Representable::Pipeline
  Insert = ::T.let(nil, ::T.untyped)
end

class Representable::Populator
  FindOrInstantiate = ::T.let(nil, ::T.untyped)
end

class Representable::Populator
  def self.apply!(options); end
end

module Representable::YAML
  include ::Representable::Hash
  include ::Representable
  def from_yaml(doc, options=T.unsafe(nil)); end

  def parse(doc, options=T.unsafe(nil)); end

  def render(*args); end

  def to_ast(options=T.unsafe(nil)); end

  def to_yaml(*args); end
end

class Representable::YAML::Binding
  def node_for(fragment); end

  def write(map, fragment, as); end

  def write_scalar(value); end
end

class Representable::YAML::Binding::Collection
  include ::Representable::Binding::Collection
  def node_for(fragments); end
end

class Representable::YAML::Binding::Collection
end

class Representable::YAML::Binding
end

module Representable::YAML::ClassMethods
  def format_engine(); end
end

module Representable::YAML::ClassMethods
end

module Representable::YAML
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  def self.included(base); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module RubyNext
  LAST_MINOR_VERSIONS = ::T.let(nil, ::T.untyped)
  LATEST_VERSION = ::T.let(nil, ::T.untyped)
  MIN_SUPPORTED_VERSION = ::T.let(nil, ::T.untyped)
  NEXT_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_NEXT_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module RubyNext::Core
end

class RubyNext::Core::Patch
  def body(); end

  def core_ext(); end

  def core_ext?(); end

  def initialize(mod=T.unsafe(nil), method:, version:, name: T.unsafe(nil), supported: T.unsafe(nil), native: T.unsafe(nil), location: T.unsafe(nil), refineable: T.unsafe(nil), core_ext: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def location(); end

  def method_name(); end

  def mod(); end

  def name(); end

  def native(); end

  def native?(); end

  def prepend?(); end

  def refineables(); end

  def singleton(); end

  def singleton?(); end

  def supported(); end

  def supported?(); end

  def to_module(); end

  def version(); end
end

class RubyNext::Core::Patch
end

class RubyNext::Core::Patches
  def <<(patch); end

  def extensions(); end

  def refined(); end
end

class RubyNext::Core::Patches
end

module RubyNext::Core
  def self.backports?(); end

  def self.core_ext?(); end

  def self.inject!(contents); end

  def self.patch(*_, &_1); end

  def self.patches(); end

  def self.refine?(); end

  def self.strategy(); end

  def self.strategy=(val); end
end

module RubyNext::Language
end

module RubyNext::Language::GemTranspiler
end

module RubyNext::Language::GemTranspiler
  def self.maybe_transpile(root_dir, lib_dir, target_dir); end
end

module RubyNext::Language
  def self.runtime?(); end

  def self.setup_gem_load_path(lib_dir=T.unsafe(nil), rbnext_dir: T.unsafe(nil), transpile: T.unsafe(nil)); end
end

module RubyNext::Utils
end

module RubyNext::Utils
  def self.refine_modules?(); end

  def self.resolve_feature_path(feature); end

  def self.source_with_lines(source, path); end
end

module RubyNext
  def self.current_ruby_version(); end

  def self.debug_enabled(); end

  def self.debug_enabled=(val); end

  def self.debug_source(source, filepath=T.unsafe(nil)); end

  def self.next_ruby_version(version=T.unsafe(nil)); end

  def self.silence_warnings(); end

  def self.silence_warnings=(silence_warnings); end

  def self.warn(msg); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellany
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module Spoom
  SPOOM_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Spoom::Cli::Bump
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Cli::Coverage
  DATA_DIR = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli::Helper
  HIGHLIGHT_COLOR = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli::Helper
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Cli::Run
  DEFAULT_FORMAT = ::T.let(nil, ::T.untyped)
  SORT_CODE = ::T.let(nil, ::T.untyped)
  SORT_ENUM = ::T.let(nil, ::T.untyped)
  SORT_LOC = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Card
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Snapshot
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Spoom::Coverage::D3
  COLOR_FALSE = ::T.let(nil, ::T.untyped)
  COLOR_IGNORE = ::T.let(nil, ::T.untyped)
  COLOR_STRICT = ::T.let(nil, ::T.untyped)
  COLOR_STRONG = ::T.let(nil, ::T.untyped)
  COLOR_TRUE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::D3::Base
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage::D3
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Coverage::Page
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Snapshot
  STRICTNESSES = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Snapshot
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Coverage::Template
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::FileTree::Node
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::FileTree
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Git
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Diagnostic
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::DocumentSymbol
  SYMBOL_KINDS = ::T.let(nil, ::T.untyped)
end

class Spoom::LSP::DocumentSymbol
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Hover
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Location
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Position
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::LSP::PrintableSymbol
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Range
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::SignatureHelp
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Printer
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet
  BIN_PATH = ::T.let(nil, ::T.untyped)
  CONFIG_PATH = ::T.let(nil, ::T.untyped)
  GEM_PATH = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Config
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Errors::Error
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Errors::Parser
  ERROR_LINE_MATCH_REGEX = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Errors::Parser
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet::Errors
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet::MetricsParser
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::MetricsParser
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet::Sigils
  SIGIL_REGEXP = ::T.let(nil, ::T.untyped)
  STRICTNESS_FALSE = ::T.let(nil, ::T.untyped)
  STRICTNESS_IGNORE = ::T.let(nil, ::T.untyped)
  STRICTNESS_INTERNAL = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRICT = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRONG = ::T.let(nil, ::T.untyped)
  STRICTNESS_TRUE = ::T.let(nil, ::T.untyped)
  VALID_STRICTNESS = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::Sigils
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Timeline
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(_); end

  def filter(*_); end
end

class Struct::ClientError
  def code(); end

  def code=(_); end

  def message(); end

  def message=(_); end
end

class Struct::ClientError
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Symbol
  def ends_with?(*_); end

  def starts_with?(*_); end
end

class Sys::Platform
  ARCH = ::T.let(nil, ::T.untyped)
  IMPL = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sys::Uname
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CTL_HW = ::T.let(nil, ::T.untyped)
  HW_MODEL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Sys::Uname::UnameStruct = Struct::UnameStruct

module TTY
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module TTY::Color
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Color::Mode
  TERM_16 = ::T.let(nil, ::T.untyped)
  TERM_256 = ::T.let(nil, ::T.untyped)
  TERM_52 = ::T.let(nil, ::T.untyped)
  TERM_64 = ::T.let(nil, ::T.untyped)
  TERM_8 = ::T.let(nil, ::T.untyped)
end

class TTY::Color::Support
  SOURCES = ::T.let(nil, ::T.untyped)
end

module TTY::Formats
  FORMATS = ::T.let(nil, ::T.untyped)
end

class TTY::Logger
  ALL = ::T.let(nil, ::T.untyped)
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  MAX_LEVELS = ::T.let(nil, ::T.untyped)
  OFF = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

class TTY::Pager
  PAGE_BREAK = ::T.let(nil, ::T.untyped)
  PROMPT_HEIGHT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Platform
  LINUX_PATTERN = ::T.let(nil, ::T.untyped)
  MAC_PATTERN = ::T.let(nil, ::T.untyped)
  UNIX_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class TTY::Plugins
  PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar
  DEC_RST = ::T.let(nil, ::T.untyped)
  DEC_SET = ::T.let(nil, ::T.untyped)
  DEC_TCEM = ::T.let(nil, ::T.untyped)
  ECMA_CHA = ::T.let(nil, ::T.untyped)
  ECMA_CLR = ::T.let(nil, ::T.untyped)
  ECMA_CSI = ::T.let(nil, ::T.untyped)
  ECMA_ESC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::BarFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::ByteFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::ByteRateFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::Converter
  GIGABYTE = ::T.let(nil, ::T.untyped)
  HOURSECONDS = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::CurrentFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::ElapsedFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::EstimatedFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::MeanByteFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::MeanRateFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::PercentFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::RateFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::TotalByteFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::ProgressBar::TotalFormatter
  MATCHER = ::T.let(nil, ::T.untyped)
end

class TTY::Screen
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Spinner
  CROSS = ::T.let(nil, ::T.untyped)
  DEC_RST = ::T.let(nil, ::T.untyped)
  DEC_SET = ::T.let(nil, ::T.untyped)
  DEC_TCEM = ::T.let(nil, ::T.untyped)
  ECMA_CHA = ::T.let(nil, ::T.untyped)
  ECMA_CLR = ::T.let(nil, ::T.untyped)
  ECMA_CSI = ::T.let(nil, ::T.untyped)
  ECMA_ESC = ::T.let(nil, ::T.untyped)
  MATCHER = ::T.let(nil, ::T.untyped)
  TICK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Table
  include ::Equatable
  include ::TTY::Table::Validatable
  include ::Enumerable
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Table::AlignmentSet
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class TTY::Table::Border
  EACH_ROW = ::T.let(nil, ::T.untyped)
  EMPTY_CHAR = ::T.let(nil, ::T.untyped)
  SPACE_CHAR = ::T.let(nil, ::T.untyped)
end

class TTY::Table::ColumnConstraint
  BORDER_WIDTH = ::T.let(nil, ::T.untyped)
  MIN_WIDTH = ::T.let(nil, ::T.untyped)
end

class TTY::Table::Operation::Alignment
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class TTY::Table::Renderer
  RENDERER_MAPPER = ::T.let(nil, ::T.untyped)
end

class TTY::Vector
  include ::Equatable
end

module TTY::Which
  VERSION = ::T.let(nil, ::T.untyped)
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

module Tapioca
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tapioca::Compilers::Dsl::Base
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Tapioca::Compilers::Dsl::Base
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Terminal::Table
  VERSION = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::AsciiBorder
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::UnicodeBorder
  ALLOWED_SEPARATOR_BORDER_STYLES = ::T.let(nil, ::T.untyped)
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
end

class Time
  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def to_default_s(); end
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

module TrackerApi
  VERSION = ::T.let(nil, ::T.untyped)
end

class TrackerApi::Client
  def activity(params=T.unsafe(nil)); end

  def api_version(); end

  def auto_paginate(); end

  def connection(); end

  def create_workspace(params); end

  def delete(path, options=T.unsafe(nil)); end

  def epic(epic_id, params=T.unsafe(nil)); end

  def get(path, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def last_response(); end

  def logger(); end

  def me(); end

  def notifications(params=T.unsafe(nil)); end

  def paginate(path, options=T.unsafe(nil), &block); end

  def patch(path, options=T.unsafe(nil)); end

  def post(path, options=T.unsafe(nil)); end

  def project(id, params=T.unsafe(nil)); end

  def projects(params=T.unsafe(nil)); end

  def put(path, options=T.unsafe(nil)); end

  def story(story_id, params=T.unsafe(nil)); end

  def token(); end

  def url(); end

  def workspace(id, params=T.unsafe(nil)); end

  def workspaces(params=T.unsafe(nil)); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

class TrackerApi::Client::Pagination
  def headers(); end

  def headers=(headers); end

  def initialize(headers); end

  def limit(); end

  def limit=(limit); end

  def more?(); end

  def next_offset(); end

  def next_page_params(); end

  def offset(); end

  def offset=(offset); end

  def returned(); end

  def returned=(returned); end

  def total(); end

  def total=(total); end
end

class TrackerApi::Client::Pagination
end

class TrackerApi::Client
end

class TrackerApi::Endpoints::Activity
  def client(); end

  def client=(client); end

  def get(params=T.unsafe(nil)); end

  def get_project(project_id, params=T.unsafe(nil)); end

  def get_story(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Activity
end

class TrackerApi::Endpoints::Attachment
  def client(); end

  def client=(client); end

  def create(comment, file); end

  def get(comment); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Attachment
end

class TrackerApi::Endpoints::Attachments
  def client(); end

  def client=(client); end

  def create(comment, files); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Attachments
end

class TrackerApi::Endpoints::Blockers
  def client(); end

  def client=(client); end

  def get(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Blockers
end

class TrackerApi::Endpoints::Comment
  def client(); end

  def client=(client); end

  def create(project_id, story_id: T.unsafe(nil), epic_id: T.unsafe(nil), params: T.unsafe(nil)); end

  def delete(comment); end

  def initialize(client); end

  def update(comment, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Comment
end

class TrackerApi::Endpoints::Comments
  def client(); end

  def client=(client); end

  def get(project_id, story_id: T.unsafe(nil), epic_id: T.unsafe(nil), params: T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Comments
end

class TrackerApi::Endpoints::Epic
  def client(); end

  def client=(client); end

  def create(project_id, params=T.unsafe(nil)); end

  def get(project_id, id, params=T.unsafe(nil)); end

  def get_epic(epic_id, params=T.unsafe(nil)); end

  def initialize(client); end

  def update(epic, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Epic
end

class TrackerApi::Endpoints::Epics
  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Epics
end

class TrackerApi::Endpoints::Iteration
  def client(); end

  def client=(client); end

  def get(project_id, iteration_number); end

  def get_analytics_cycle_time_details(project_id, iteration_number); end

  def get_history(project_id, iteration_number); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Iteration
end

class TrackerApi::Endpoints::Iterations
  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Iterations
end

class TrackerApi::Endpoints::Labels
  def add(project_id, params=T.unsafe(nil)); end

  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Labels
end

class TrackerApi::Endpoints::Me
  def client(); end

  def client=(client); end

  def get(); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Me
end

class TrackerApi::Endpoints::Memberships
  def add(project_id, params=T.unsafe(nil)); end

  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Memberships
end

class TrackerApi::Endpoints::Notifications
  def client(); end

  def client=(client); end

  def get(params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Notifications
end

class TrackerApi::Endpoints::Project
  def client(); end

  def client=(client); end

  def get(id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Project
end

class TrackerApi::Endpoints::Projects
  def client(); end

  def client=(client); end

  def get(params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Projects
end

class TrackerApi::Endpoints::Release
  def client(); end

  def client=(client); end

  def get(project_id, id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Release
end

class TrackerApi::Endpoints::Releases
  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Releases
end

class TrackerApi::Endpoints::Review
  def client(); end

  def client=(client); end

  def initialize(client); end

  def update(review, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Review
end

class TrackerApi::Endpoints::Reviews
  def client(); end

  def client=(client); end

  def get(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Reviews
end

class TrackerApi::Endpoints::Search
  def client(); end

  def client=(client); end

  def get(project_id, query, options=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Search
end

class TrackerApi::Endpoints::Stories
  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def get_release(project_id, release_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Stories
end

class TrackerApi::Endpoints::Story
  def client(); end

  def client=(client); end

  def create(project_id, params=T.unsafe(nil)); end

  def get(project_id, id, params=T.unsafe(nil)); end

  def get_story(story_id, params=T.unsafe(nil)); end

  def initialize(client); end

  def update(story, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Story
end

class TrackerApi::Endpoints::StoryOwners
  def client(); end

  def client=(client); end

  def get(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::StoryOwners
end

class TrackerApi::Endpoints::StoryTransitions
  def client(); end

  def client=(client); end

  def get(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::StoryTransitions
end

class TrackerApi::Endpoints::Task
  def client(); end

  def client=(client); end

  def create(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end

  def update(task, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Task
end

class TrackerApi::Endpoints::Tasks
  def client(); end

  def client=(client); end

  def get(project_id, story_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Tasks
end

class TrackerApi::Endpoints::Webhook
  def client(); end

  def client=(client); end

  def create(project_id, params=T.unsafe(nil)); end

  def delete(webhook); end

  def delete_from_project(project_id, webhook_id); end

  def get(project_id, id, params=T.unsafe(nil)); end

  def initialize(client); end

  def update(webhook, params=T.unsafe(nil)); end
end

class TrackerApi::Endpoints::Webhook
end

class TrackerApi::Endpoints::Webhooks
  def client(); end

  def client=(client); end

  def get(project_id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Webhooks
end

class TrackerApi::Endpoints::Workspace
  def client(); end

  def client=(client); end

  def create(params=T.unsafe(nil)); end

  def get(id, params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Workspace
end

class TrackerApi::Endpoints::Workspaces
  def client(); end

  def client=(client); end

  def get(params=T.unsafe(nil)); end

  def initialize(client); end
end

class TrackerApi::Endpoints::Workspaces
end

class TrackerApi::FileUtility
end

class TrackerApi::FileUtility
  def self.check_files_exist(files); end

  def self.get_file_upload(file); end
end

class TrackerApi::Logger
  def debug(*args, &block); end

  def error(*args, &block); end

  def fatal(*args, &block); end

  def info(*args, &block); end

  def initialize(app, logger=T.unsafe(nil)); end

  def warn(*args, &block); end
end

class TrackerApi::Logger
  extend ::Forwardable
end

class TrackerApi::Resources::Account
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def created_at=(new_regular_object); end

  def days_left=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def over_the_limit=(new_regular_object); end

  def plan=(new_regular_object); end

  def status=(new_regular_object); end

  def updated_at=(new_regular_object); end

  def url=(new_regular_object); end
end

class TrackerApi::Resources::Account
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Activity
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def changes=(new_regular_object); end

  def client=(new_regular_object); end

  def guid=(new_regular_object); end

  def highlight=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def message=(new_regular_object); end

  def occurred_at=(new_regular_object); end

  def performed_by=(new_regular_object); end

  def primary_resources=(new_regular_object); end

  def project=(data); end

  def project_version=(new_regular_object); end
end

class TrackerApi::Resources::Activity
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Blocker
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def created_at=(new_regular_object); end

  def description=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def person_id=(new_regular_object); end

  def project_id=(new_regular_object); end

  def resolved=(new_regular_object); end

  def story_id=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Blocker
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Change
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def change_type=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def new_values=(new_regular_object); end

  def original_values=(new_regular_object); end

  def story_type=(new_regular_object); end
end

class TrackerApi::Resources::Change
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Comment
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def attachments(reload: T.unsafe(nil)); end

  def client=(new_regular_object); end

  def commit_identifier=(new_regular_object); end

  def commit_type=(new_regular_object); end

  def create_attachments(params); end

  def created_at=(new_regular_object); end

  def delete(); end

  def delete_attachments(attachment_ids=T.unsafe(nil)); end

  def epic_id=(new_regular_object); end

  def file_attachment_ids=(new_regular_object); end

  def file_attachment_ids_to_add=(new_regular_object); end

  def file_attachment_ids_to_remove=(new_regular_object); end

  def file_attachments=(new_regular_object); end

  def google_attachment_ids=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def person=(new_regular_object); end

  def person_id=(new_regular_object); end

  def project_id=(new_regular_object); end

  def save(); end

  def story_id=(new_regular_object); end

  def text=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Comment::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Comment::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Comment
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::CycleTimeDetails
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def delivered_count=(new_regular_object); end

  def delivered_time=(new_regular_object); end

  def finished_count=(new_regular_object); end

  def finished_time=(new_regular_object); end

  def id=(new_regular_object); end

  def iteration_number=(new_regular_object); end

  def kind=(new_regular_object); end

  def project_id=(new_regular_object); end

  def rejected_count=(new_regular_object); end

  def rejected_time=(new_regular_object); end

  def started_count=(new_regular_object); end

  def started_time=(new_regular_object); end

  def story_id=(new_regular_object); end

  def total_cycle_time=(new_regular_object); end
end

class TrackerApi::Resources::CycleTimeDetails
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::DailyHistoryContainer
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def data=(new_regular_object); end

  def header=(new_regular_object); end

  def id=(new_regular_object); end

  def iteration_number=(new_regular_object); end

  def kind=(new_regular_object); end

  def project_id=(new_regular_object); end
end

class TrackerApi::Resources::DailyHistoryContainer
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Epic
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def comment_ids=(new_regular_object); end

  def comments(reload: T.unsafe(nil)); end

  def comments=(new_regular_object); end

  def completed_at=(new_regular_object); end

  def create_comment(params); end

  def created_at=(new_regular_object); end

  def description=(new_regular_object); end

  def follower_ids=(new_regular_object); end

  def followers=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def label=(new_regular_object); end

  def label_id=(new_regular_object); end

  def name=(new_regular_object); end

  def project_id=(new_regular_object); end

  def save(); end

  def updated_at=(new_regular_object); end

  def url=(new_regular_object); end
end

class TrackerApi::Resources::Epic::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Epic::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Epic
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::EpicsSearchResult
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def epics=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def total_hits=(new_regular_object); end

  def total_hits_with_done=(new_regular_object); end
end

class TrackerApi::Resources::EpicsSearchResult
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::FileAttachment
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def big_url=(new_regular_object); end

  def comment=(new_regular_object); end

  def content_type=(new_regular_object); end

  def created_at=(new_regular_object); end

  def delete(); end

  def download_url=(new_regular_object); end

  def filename=(new_regular_object); end

  def height=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def size=(new_regular_object); end

  def thumbnail_url=(new_regular_object); end

  def thumbnailable=(new_regular_object); end

  def uploaded=(new_regular_object); end

  def uploader_id=(new_regular_object); end

  def width=(new_regular_object); end
end

class TrackerApi::Resources::FileAttachment
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Iteration
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Equalizer::Methods
  def cycle_time_details(); end

  def get_history(); end

  def stories=(data); end
end

class TrackerApi::Resources::Iteration
  extend ::Virtus::Extensions::AllowedWriterMethods
end

class TrackerApi::Resources::Label
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def created_at=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def project_id=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Label::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Label::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Label
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Me
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def api_token=(new_regular_object); end

  def email=(new_regular_object); end

  def has_google_identity=(new_regular_object); end

  def id=(new_regular_object); end

  def initials=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def project_ids=(new_regular_object); end

  def projects=(new_regular_object); end

  def receives_in_app_notifications=(new_regular_object); end

  def time_zone=(new_regular_object); end

  def username=(new_regular_object); end

  def workspace_ids=(new_regular_object); end

  def workspaces=(new_regular_object); end
end

class TrackerApi::Resources::Me
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::MembershipSummary
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def last_viewed_at=(new_regular_object); end

  def project_color=(new_regular_object); end

  def project_id=(new_regular_object); end

  def project_name=(new_regular_object); end

  def role=(new_regular_object); end
end

class TrackerApi::Resources::MembershipSummary
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Notification
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def context=(new_regular_object); end

  def created_at=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def message=(new_regular_object); end

  def performer=(new_regular_object); end

  def project=(data); end

  def story=(data); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Notification
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Person
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def email=(new_regular_object); end

  def id=(new_regular_object); end

  def initials=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def username=(new_regular_object); end
end

class TrackerApi::Resources::Person
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::PrimaryResource
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def story_type=(new_regular_object); end

  def url=(new_regular_object); end
end

class TrackerApi::Resources::PrimaryResource
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Project
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def account=(new_regular_object); end

  def account_id=(new_regular_object); end

  def activity(params=T.unsafe(nil)); end

  def add_membership(params); end

  def add_webhook(params); end

  def atom_enabled=(new_regular_object); end

  def bugs_and_chores_are_estimatable=(new_regular_object); end

  def client=(new_regular_object); end

  def create_epic(params); end

  def create_story(params); end

  def created_at=(new_regular_object); end

  def current_iteration_number=(new_regular_object); end

  def current_velocity=(new_regular_object); end

  def delete_webhook(webhook_id); end

  def description=(new_regular_object); end

  def enable_following=(new_regular_object); end

  def enable_incoming_emails=(new_regular_object); end

  def enable_planned_mode=(new_regular_object); end

  def enable_tasks=(new_regular_object); end

  def epic(epic_id, params=T.unsafe(nil)); end

  def epic_ids=(new_regular_object); end

  def epics(params=T.unsafe(nil)); end

  def epics=(new_regular_object); end

  def has_google_domain=(new_regular_object); end

  def id=(new_regular_object); end

  def initial_velocity=(new_regular_object); end

  def iteration_length=(new_regular_object); end

  def iterations(params=T.unsafe(nil)); end

  def kind=(new_regular_object); end

  def label_ids=(new_regular_object); end

  def label_list(); end

  def labels(params=T.unsafe(nil)); end

  def labels=(new_regular_object); end

  def memberships(params=T.unsafe(nil)); end

  def name=(new_regular_object); end

  def number_of_done_iterations_to_show=(new_regular_object); end

  def point_scale=(new_regular_object); end

  def point_scale_is_custom=(new_regular_object); end

  def profile_content=(new_regular_object); end

  def public=(new_regular_object); end

  def releases(params=T.unsafe(nil)); end

  def search(query, params=T.unsafe(nil)); end

  def start_date=(new_regular_object); end

  def start_time=(new_regular_object); end

  def stories(params=T.unsafe(nil)); end

  def story(story_id, params=T.unsafe(nil)); end

  def time_zone=(new_regular_object); end

  def updated_at=(new_regular_object); end

  def velocity_averaged_over=(new_regular_object); end

  def version=(new_regular_object); end

  def webhook(webhook_id, params=T.unsafe(nil)); end

  def webhooks(params=T.unsafe(nil)); end

  def webhooks=(new_regular_object); end

  def week_start_day=(new_regular_object); end
end

class TrackerApi::Resources::Project
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::ProjectMembership
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def person=(new_regular_object); end

  def person_id=(new_regular_object); end

  def project_color=(new_regular_object); end

  def project_id=(new_regular_object); end

  def role=(new_regular_object); end

  def wants_comment_notification_emails=(new_regular_object); end
end

class TrackerApi::Resources::ProjectMembership
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Release
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def accepted_at=(new_regular_object); end

  def client=(new_regular_object); end

  def created_at=(new_regular_object); end

  def current_state=(new_regular_object); end

  def deadline=(new_regular_object); end

  def description=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def labels=(new_regular_object); end

  def name=(new_regular_object); end

  def project_id=(new_regular_object); end

  def stories(params=T.unsafe(nil)); end

  def updated_at=(new_regular_object); end

  def url=(new_regular_object); end
end

class TrackerApi::Resources::Release
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Review
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def created_at=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def project_id=(new_regular_object); end

  def review_type=(new_regular_object); end

  def review_type_id=(new_regular_object); end

  def reviewer_id=(new_regular_object); end

  def save(); end

  def status=(new_regular_object); end

  def story_id=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Review::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Review::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Review
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::ReviewType
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def created_at=(new_regular_object); end

  def hidden=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def project_id=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::ReviewType
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::SearchResultContainer
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def epics=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def query=(new_regular_object); end

  def stories=(new_regular_object); end
end

class TrackerApi::Resources::SearchResultContainer
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

module TrackerApi::Resources::Shared::Base
end

module TrackerApi::Resources::Shared::Base
  def self.included(base); end
end

class TrackerApi::Resources::StoriesSearchResult
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def stories=(new_regular_object); end

  def total_hits=(new_regular_object); end

  def total_hits_with_done=(new_regular_object); end

  def total_points=(new_regular_object); end

  def total_points_completed=(new_regular_object); end
end

class TrackerApi::Resources::StoriesSearchResult
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Story
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def accepted_at=(new_regular_object); end

  def activity(params=T.unsafe(nil)); end

  def add_label(label); end

  def add_owner(owner); end

  def after_id=(new_regular_object); end

  def before_id=(new_regular_object); end

  def blockers(params=T.unsafe(nil)); end

  def blockers=(new_regular_object); end

  def client=(new_regular_object); end

  def comment_ids=(new_regular_object); end

  def comments(reload: T.unsafe(nil)); end

  def comments=(new_regular_object); end

  def create_comment(params); end

  def create_task(params); end

  def created_at=(new_regular_object); end

  def current_state=(new_regular_object); end

  def deadline=(new_regular_object); end

  def description=(new_regular_object); end

  def estimate=(new_regular_object); end

  def external_id=(new_regular_object); end

  def follower_ids=(new_regular_object); end

  def followers=(new_regular_object); end

  def id=(new_regular_object); end

  def integration_id=(new_regular_object); end

  def kind=(new_regular_object); end

  def label_ids=(new_regular_object); end

  def label_list(); end

  def labels=(new_regular_object); end

  def name=(new_regular_object); end

  def owned_by=(new_regular_object); end

  def owned_by_id=(new_regular_object); end

  def owner_ids=(new_regular_object); end

  def owners(params=T.unsafe(nil)); end

  def owners=(new_regular_object); end

  def planned_iteration_number=(new_regular_object); end

  def project_id=(new_regular_object); end

  def requested_by=(new_regular_object); end

  def requested_by_id=(new_regular_object); end

  def reviews(params=T.unsafe(nil)); end

  def reviews=(new_regular_object); end

  def save(); end

  def story_type=(new_regular_object); end

  def task_ids=(new_regular_object); end

  def tasks(params=T.unsafe(nil)); end

  def tasks=(new_regular_object); end

  def transitions(params=T.unsafe(nil)); end

  def transitions=(new_regular_object); end

  def updated_at=(new_regular_object); end

  def url=(new_regular_object); end
end

class TrackerApi::Resources::Story::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Story::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Story
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::StoryTransition
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def id=(new_regular_object); end

  def occurred_at=(new_regular_object); end

  def state=(new_regular_object); end
end

class TrackerApi::Resources::StoryTransition
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Task
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def complete=(new_regular_object); end

  def created_at=(new_regular_object); end

  def description=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def position=(new_regular_object); end

  def project_id=(new_regular_object); end

  def save(); end

  def story_id=(new_regular_object); end

  def updated_at=(new_regular_object); end
end

class TrackerApi::Resources::Task::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Task::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Task
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::TimeZone
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Extensions::AllowedWriterMethods
  include ::Virtus::ValueObject::AllowedWriterMethods
  include ::Virtus::ValueObject::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Equalizer::Methods
end

class TrackerApi::Resources::TimeZone
  extend ::Virtus::Extensions::AllowedWriterMethods
end

class TrackerApi::Resources::Webhook
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def created_at=(new_regular_object); end

  def delete(); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def project_id=(new_regular_object); end

  def save(); end

  def updated_at=(new_regular_object); end

  def webhook_url=(new_regular_object); end

  def webhook_version=(new_regular_object); end
end

class TrackerApi::Resources::Webhook::UpdateRepresenter
  include ::Representable::JSON
  include ::Representable::Hash
end

class TrackerApi::Resources::Webhook::UpdateRepresenter
  extend ::Representable::JSON::ClassMethods
end

class TrackerApi::Resources::Webhook
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrackerApi::Resources::Workspace
  include ::TrackerApi::Resources::Shared::Base
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::Virtus::DirtyAttribute
  include ::Virtus::DirtyAttribute::InitiallyClean
  include ::Equalizer::Methods
  def client=(new_regular_object); end

  def created_at=(new_regular_object); end

  def id=(new_regular_object); end

  def kind=(new_regular_object); end

  def name=(new_regular_object); end

  def person=(new_regular_object); end

  def person_id=(new_regular_object); end

  def project_ids=(new_regular_object); end

  def projects=(new_regular_object); end
end

class TrackerApi::Resources::Workspace
  extend ::Virtus::Extensions::AllowedWriterMethods
  def self.attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module Uber::InheritableAttr
  def inheritable_attr(name, options=T.unsafe(nil)); end
end

class Uber::InheritableAttr::Clone
end

class Uber::InheritableAttr::Clone
  def self.call(value, uncloneable=T.unsafe(nil)); end

  def self.uncloneable(); end
end

module Uber::InheritableAttr
  def self.inherit_for(klass, name, options=T.unsafe(nil)); end
end

Uber::InheritableAttribute = Uber::InheritableAttr

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module UnicodeUtils
  CANONICAL_DECOMPOSITION_MAP = ::T.let(nil, ::T.untyped)
  CASEFOLD_C_MAP = ::T.let(nil, ::T.untyped)
  CASEFOLD_F_MAP = ::T.let(nil, ::T.untyped)
  CASEFOLD_S_MAP = ::T.let(nil, ::T.untyped)
  CASE_IGNORABLE_SET = ::T.let(nil, ::T.untyped)
  CDATA_DIR = ::T.let(nil, ::T.untyped)
  CN_CODE_POINT_TYPE = ::T.let(nil, ::T.untyped)
  COMBINING_CLASS_MAP = ::T.let(nil, ::T.untyped)
  COMPATIBILITY_DECOMPOSITION_MAP = ::T.let(nil, ::T.untyped)
  CP_PREFERRED_ALIAS_STRING_MAP = ::T.let(nil, ::T.untyped)
  EAST_ASIAN_WIDTH_MAP_PER_CP = ::T.let(nil, ::T.untyped)
  EAST_ASIAN_WIDTH_RANGES = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_ALIAS_MAP = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_BASIC_WIDTH_MAP = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_CODE_POINT_TYPE = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_IS_GRAPHIC_MAP = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_PER_CP_MAP = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_RANGES = ::T.let(nil, ::T.untyped)
  GENERAL_CATEGORY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  GRAPHEME_CLUSTER_BREAK_MAP = ::T.let(nil, ::T.untyped)
  JAMO_SHORT_NAME_MAP = ::T.let(nil, ::T.untyped)
  NAME_ALIASES_MAP = ::T.let(nil, ::T.untyped)
  NAME_MAP = ::T.let(nil, ::T.untyped)
  PROP_DEFAULT_IGNORABLE_SET = ::T.let(nil, ::T.untyped)
  PROP_LOWERCASE_SET = ::T.let(nil, ::T.untyped)
  PROP_UPPERCASE_SET = ::T.let(nil, ::T.untyped)
  SIMPLE_DOWNCASE_MAP = ::T.let(nil, ::T.untyped)
  SIMPLE_TITLECASE_MAP = ::T.let(nil, ::T.untyped)
  SIMPLE_UPCASE_MAP = ::T.let(nil, ::T.untyped)
  SOFT_DOTTED_SET = ::T.let(nil, ::T.untyped)
  SPECIAL_DOWNCASE_MAP = ::T.let(nil, ::T.untyped)
  SPECIAL_TITLECASE_MAP = ::T.let(nil, ::T.untyped)
  SPECIAL_UPCASE_MAP = ::T.let(nil, ::T.untyped)
  TITLECASE_LETTER_SET = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WHITE_SPACE_SET = ::T.let(nil, ::T.untyped)
  WORD_BREAK_MAP = ::T.let(nil, ::T.untyped)
end

class UnicodeUtils::Codepoint
  RANGE = ::T.let(nil, ::T.untyped)
end

module UnicodeUtils::Impl
  CANONICAL_COMPOSITION_MAP = ::T.let(nil, ::T.untyped)
  COMPOSITION_EXCLUSION_SET = ::T.let(nil, ::T.untyped)
  CONDITIONAL_DOWNCASE_MAP = ::T.let(nil, ::T.untyped)
  CONDITIONAL_TITLECASE_MAP = ::T.let(nil, ::T.untyped)
  CONDITIONAL_UPCASE_MAP = ::T.let(nil, ::T.untyped)
  DEBUG_COLUMNS = ::T.let(nil, ::T.untyped)
  EAST_ASIAN_WIDTH_SYMBOL_MAP = ::T.let(nil, ::T.untyped)
  LANGS_WITH_RULES = ::T.let(nil, ::T.untyped)
  NAME_ALIAS_TYPE_TO_SYMBOL_MAP = ::T.let(nil, ::T.untyped)
end

module VCR
  CassetteMutex = ::T.let(nil, ::T.untyped)
  MainThread = ::T.let(nil, ::T.untyped)
end

class VCR::Cassette
  VALID_RECORD_MODES = ::T.let(nil, ::T.untyped)
end

module VCR::Cassette::Serializers::Compressed
  def deserialize(string); end

  def file_extension(); end

  def serialize(hash); end
end

module VCR::Cassette::Serializers::Compressed
  extend ::VCR::Cassette::Serializers::Compressed
end

module VCR::Cassette::Serializers::JSON
  def deserialize(string); end

  def file_extension(); end

  def serialize(hash); end
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
end

module VCR::Cassette::Serializers::JSON
  extend ::VCR::Cassette::Serializers::JSON
  extend ::VCR::Cassette::EncodingErrorHandling
end

module VCR::Cassette::Serializers::Psych
  def deserialize(string); end

  def file_extension(); end

  def serialize(hash); end
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
end

module VCR::Cassette::Serializers::Psych
  extend ::VCR::Cassette::Serializers::Psych
  extend ::VCR::Cassette::EncodingErrorHandling
end

module VCR::Cassette::Serializers::Syck
  def deserialize(string); end

  def file_extension(); end

  def serialize(hash); end
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
end

module VCR::Cassette::Serializers::Syck
  extend ::VCR::Cassette::Serializers::Syck
  extend ::VCR::Cassette::EncodingErrorHandling
end

module VCR::Cassette::Serializers::YAML
  def deserialize(string); end

  def file_extension(); end

  def serialize(hash); end
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
end

module VCR::Cassette::Serializers::YAML
  extend ::VCR::Cassette::Serializers::YAML
  extend ::VCR::Cassette::EncodingErrorHandling
end

class VCR::CucumberTags
  def initialize(main_object); end

  def tag(*tag_names); end

  def tags(*tag_names); end
end

class VCR::CucumberTags::ScenarioNameBuilder
  def cassette_name(); end

  def examples_table(*_); end

  def examples_table_row(row); end

  def feature(feature); end

  def initialize(test_case); end

  def scenario(*_); end

  def scenario_outline(feature); end
end

class VCR::CucumberTags::ScenarioNameBuilder
end

class VCR::CucumberTags
  def self.add_tag(tag); end

  def self.tags(); end
end

class VCR::Errors::UnhandledHTTPRequestError
  ALL_SUGGESTIONS = ::T.let(nil, ::T.untyped)
end

class VCR::HTTPInteraction::HookAware
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module VCR::InternetConnection
  def available?(); end
  EXAMPLE_HOST = ::T.let(nil, ::T.untyped)
end

module VCR::InternetConnection
  extend ::VCR::InternetConnection
end

class VCR::LinkedCassette
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class VCR::Middleware::Rack
  include ::VCR::VariableArgsBlockCaller
  def call(env); end

  def initialize(app, &block); end
end

class VCR::Middleware::Rack
end

module VCR::RSpec::Metadata
  def configure!(); end
end

module VCR::RSpec::Metadata
  extend ::VCR::RSpec::Metadata
end

class VCR::Request::FiberAware
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class VCR::Request::Typed
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class VCR::RequestIgnorer
  LOCALHOST_ALIASES = ::T.let(nil, ::T.untyped)
end

class VCR::RequestMatcherRegistry
  DEFAULT_MATCHERS = ::T.let(nil, ::T.untyped)
end

class VCR::Response
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
end

module Verse
  ANSI = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  NEWLINE_RE = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  SPACE_RE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Verse::Sanitizer
  ANSI_MATCHER = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
end

class Verse::Truncation
  DEFAULT_LENGTH = ::T.let(nil, ::T.untyped)
  DEFAULT_TRAILING = ::T.let(nil, ::T.untyped)
end

class Verse::Wrapping
  DEFAULT_WIDTH = ::T.let(nil, ::T.untyped)
end

module Virtus::ClassInclusions::Methods
  def allowed_writer_methods(); end
end

module Virtus::ClassInclusions::Methods
end

module Virtus::DirtyAttribute
  def attribute_clean!(name); end

  def attribute_dirty!(name, value); end

  def attribute_dirty?(name, options=T.unsafe(nil)); end

  def clean!(); end

  def clean?(); end

  def dirty?(); end

  def dirty_attributes(); end

  def original_attributes(); end
end

module Virtus::DirtyAttribute::InitiallyClean
  def initialize(*args); end
end

module Virtus::DirtyAttribute::InitiallyClean
end

module Virtus::DirtyAttribute
  def self.included(base); end
end

module Virtus::Extensions::AllowedWriterMethods
  def allowed_writer_methods(); end
  INVALID_WRITER_METHODS = ::T.let(nil, ::T.untyped)
  WRITER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Virtus::Extensions::AllowedWriterMethods
end

module Virtus::InstanceMethods
  def [](name); end

  def []=(name, value); end

  def freeze(); end

  def reset_attribute(attribute_name); end

  def set_default_attributes(); end

  def set_default_attributes!(); end
end

module Virtus::InstanceMethods::Constructor
  def initialize(attributes=T.unsafe(nil)); end
end

module Virtus::InstanceMethods::Constructor
end

module Virtus::InstanceMethods::MassAssignment
  def attributes(); end

  def attributes=(attributes); end

  def to_h(); end

  def to_hash(); end
end

module Virtus::InstanceMethods::MassAssignment
end

module Virtus::InstanceMethods
end

module Virtus::Model::Constructor
end

module Virtus::Model::Constructor
end

module Virtus::Model::Core
end

module Virtus::Model::Core
  def self.extended(descendant); end
end

module Virtus::Model::MassAssignment
end

module Virtus::Model::MassAssignment
end

module Virtus::ValueObject::AllowedWriterMethods
  def allowed_writer_methods(); end
end

module Virtus::ValueObject::AllowedWriterMethods
end

module Virtus::ValueObject::InstanceMethods
  def clone(); end

  def dup(); end

  def with(attribute_updates); end
end

module Virtus::ValueObject::InstanceMethods
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end

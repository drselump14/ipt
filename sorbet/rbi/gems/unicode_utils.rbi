# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/unicode_utils/all/unicode_utils.rbi
#
# unicode_utils-1.4.0

module UnicodeUtils
  def canonical_decomposition(str); end
  def canonical_equivalents?(a, b); end
  def case_ignorable_char?(char); end
  def cased_char?(char); end
  def casefold(str); end
  def char_display_width(char); end
  def char_name(char); end
  def char_type(char); end
  def code_point_type(integer); end
  def combining_class(char); end
  def compatibility_decomposition(str); end
  def debug(str, opts = nil); end
  def default_ignorable_char?(char); end
  def display_width(str); end
  def downcase(str, language_id = nil); end
  def each_grapheme(str); end
  def each_word(str); end
  def east_asian_width(char); end
  def gc(char); end
  def general_category(char); end
  def graphic_char?(char); end
  def grep(regexp); end
  def hangul_syllable_decomposition(char); end
  def jamo_short_name(char); end
  def lowercase_char?(char); end
  def name_aliases(char); end
  def nfc(str); end
  def nfd(str); end
  def nfkc(str); end
  def nfkd(str); end
  def self.canonical_decomposition(str); end
  def self.canonical_equivalents?(a, b); end
  def self.case_ignorable_char?(char); end
  def self.cased_char?(char); end
  def self.casefold(str); end
  def self.char_display_width(char); end
  def self.char_name(char); end
  def self.char_type(char); end
  def self.code_point_type(integer); end
  def self.combining_class(char); end
  def self.compatibility_decomposition(str); end
  def self.debug(str, opts = nil); end
  def self.default_ignorable_char?(char); end
  def self.display_width(str); end
  def self.downcase(str, language_id = nil); end
  def self.each_grapheme(str); end
  def self.each_word(str); end
  def self.east_asian_width(char); end
  def self.gc(char); end
  def self.general_category(char); end
  def self.graphic_char?(char); end
  def self.grep(regexp); end
  def self.hangul_syllable_decomposition(char); end
  def self.jamo_short_name(char); end
  def self.lowercase_char?(char); end
  def self.name_aliases(char); end
  def self.nfc(str); end
  def self.nfd(str); end
  def self.nfkc(str); end
  def self.nfkd(str); end
  def self.sid(code_point); end
  def self.simple_casefold(str); end
  def self.simple_downcase(str); end
  def self.simple_upcase(str); end
  def self.soft_dotted_char?(char); end
  def self.titlecase(str, language_id = nil); end
  def self.titlecase_char?(char); end
  def self.upcase(str, language_id = nil); end
  def self.uppercase_char?(char); end
  def self.white_space_char?(char); end
  def sid(code_point); end
  def simple_casefold(str); end
  def simple_downcase(str); end
  def simple_upcase(str); end
  def soft_dotted_char?(char); end
  def titlecase(str, language_id = nil); end
  def titlecase_char?(char); end
  def upcase(str, language_id = nil); end
  def uppercase_char?(char); end
  def white_space_char?(char); end
end
module UnicodeUtils::Impl
  def self.append_hangul_syllable_decomposition(str, s); end
  def self.append_recursive_canonical_decomposition_mapping(str, mapping); end
  def self.append_recursive_compatibility_decomposition_mapping(str, cp); end
  def self.column_widths(table); end
  def self.composition(str); end
  def self.conditional_downcase_mapping(cp, str, pos, language_id); end
  def self.conditional_titlecase_mapping(cp, str, pos, language_id); end
  def self.conditional_upcase_mapping(cp, str, pos, language_id); end
  def self.open_cdata_file(filename, &block); end
  def self.print_row(row, column_widths, io); end
  def self.print_separator_row(column_widths, io); end
  def self.print_table(table, io); end
  def self.put_into_canonical_order(str); end
  def self.read_code_point_map(filename); end
  def self.read_code_point_set(filename); end
  def self.read_combining_class_map; end
  def self.read_conditional_casings(filename); end
  def self.read_east_asian_width_per_cp(filename); end
  def self.read_east_asian_width_ranges(filename); end
  def self.read_general_category_per_cp(filename); end
  def self.read_general_category_ranges(filename); end
  def self.read_hexdigit_map(filename); end
  def self.read_multivalued_map(filename); end
  def self.read_name_aliases(filename); end
  def self.read_names(filename); end
  def self.read_range_to_hexdigit_list(filename); end
  def self.read_symbol_map(filename); end
  def self.word_break?(cs, i); end
end
class UnicodeUtils::Impl::ConditionalCasing
  def context_match?(str, pos); end
  def initialize(mapping); end
  def mapping; end
end
class UnicodeUtils::Impl::BeforeDotConditionalCasing < UnicodeUtils::Impl::ConditionalCasing
  def context_match?(str, pos); end
end
class UnicodeUtils::Impl::NotBeforeDotConditionalCasing < UnicodeUtils::Impl::BeforeDotConditionalCasing
  def context_match?(str, pos); end
end
class UnicodeUtils::Impl::MoreAboveConditionalCasing < UnicodeUtils::Impl::ConditionalCasing
  def context_match?(str, pos); end
end
class UnicodeUtils::Impl::AfterIConditionalCasing < UnicodeUtils::Impl::ConditionalCasing
  def context_match?(str, pos); end
end
class UnicodeUtils::Impl::AfterSoftDottedConditionalCasing < UnicodeUtils::Impl::ConditionalCasing
  def context_match?(str, pos); end
end
class UnicodeUtils::Impl::FinalSigmaConditionalCasing < UnicodeUtils::Impl::ConditionalCasing
  def after_match?(str, pos); end
  def before_match?(str, pos); end
  def context_match?(str, pos); end
end
module UnicodeUtils::Impl::NFC
  def self.blocked?(b, c); end
  def self.primary_composite?(cp); end
end
class UnicodeUtils::Codepoint
  def hexbytes; end
  def initialize(int); end
  def inspect; end
  def name; end
  def ord; end
  def to_s; end
  def uplus; end
end
class UnicodeUtils::NameAlias
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name, type); end
  def inspect; end
  def name; end
  def to_s; end
  def type; end
end

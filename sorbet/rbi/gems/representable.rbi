# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/representable/all/representable.rbi
#
# representable-3.1.1

module Representable
  def create_representation_with(doc, options, format); end
  def normalize_options(user_options: nil, **options); end
  def representable_attrs; end
  def representable_attrs=(arg0); end
  def representable_bindings_for(format, options); end
  def representable_map!(doc, options, format, method); end
  def representable_map(options, format); end
  def representation_wrap(options = nil); end
  def represented; end
  def self.Option(value); end
  def self.included(base); end
  def update_properties_from(doc, options, format); end
end
class Representable::Option < Trailblazer::Option
  def self.build(value); end
  def self.callable?(value); end
end
class Representable::Config < Declarative::Definitions
  def infer_name_for(name); end
  def initialize(*arg0); end
  def options; end
  def remove(name); end
  def wrap=(value); end
  def wrap_for(represented, options = nil, &block); end
end
class Representable::Definition < Declarative::Definitions::Definition
  def [](name); end
  def array?; end
  def create_binding(*args); end
  def delete!(name); end
  def dynamic_options; end
  def getter; end
  def handle_as!(options); end
  def handle_extend!(options); end
  def has_default?; end
  def hash?; end
  def initialize(sym, options = nil, &block); end
  def inspect; end
  def merge!(options, &block); end
  def name; end
  def representable?; end
  def representer_module; end
  def runtime_options!(options); end
  def setter; end
  def setup!(options, &block); end
  def typed?; end
end
module Representable::Declarative
  def collection(name, options = nil, &block); end
  def default_nested_class; end
  def definitions; end
  def hash(name = nil, options = nil, &block); end
  def nested(name, options = nil, &block); end
  def nested_builder; end
  def representable_attrs; end
  def representation_wrap=(name); end
  include Declarative::Heritage::DSL
  include Declarative::Schema::DSL
  include Declarative::Schema::Feature
end
module Representable::Function
end
class Representable::Function::Prepare
  def call(input, options); end
end
class Representable::Function::Decorate
  def call(object, options); end
  def prepare_for(mod, object, binding); end
end
module Representable::CreateObject
end
module Representable::Binding::Factories
  def collect_for(item_functions); end
  def default_parse_fragment_functions; end
  def default_parse_init_functions; end
  def default_post_functions; end
  def default_render_fragment_functions; end
  def default_render_init_functions; end
  def parse_functions; end
  def pipeline_for(name, input, options); end
  def render_functions; end
end
class Representable::Binding
  def [](name); end
  def cached_representer; end
  def cached_representer=(arg0); end
  def default_for(value); end
  def exec_context(options); end
  def getter; end
  def initialize(definition); end
  def name; end
  def parse_pipeline(input, options); end
  def render_pipeline(input, options); end
  def self.build(definition); end
  def setter; end
  def setup_exec_context!; end
  def skipable_empty_value?(value); end
  extend Uber::Delegates
  include Anonymous_Module_60
  include Representable::Binding::Deprecatable
  include Representable::Binding::EvaluateOption
  include Representable::Binding::Factories
end
class Representable::Binding::Map < Array
  def <<(binding); end
  def call(method, options); end
end
class Representable::Binding::FragmentNotFound
end
module Anonymous_Module_60
  def array?(*args, &block); end
  def has_default?(*args, &block); end
  def representable?(*args, &block); end
  def typed?(*args, &block); end
  extend Forwardable
end
module Representable::Binding::Deprecatable
  def compile_fragment(options); end
  def uncompile_fragment(options); end
end
module Representable::Binding::EvaluateOption
  def evaluate_option(name, input, options); end
end
module Representable::Binding::Collection
  def skipable_empty_value?(value); end
end
class Representable::DeserializeError < RuntimeError
end
class Representable::Pipeline < Array
  def call(input, options); end
  def evaluate(block, input, options); end
  extend Representable::Pipeline::Macros
end
class Representable::Pipeline::Stop
end
module Representable::Pipeline::Macros
  def insert(functions, new_function, options); end
end
class Representable::Collect < Representable::Pipeline
  def call(input, options); end
end
class Representable::Collect::Hash < Representable::Pipeline
  def call(input, options); end
end
module Representable::Pipeline::Function
end
class Representable::Pipeline::Function::Insert
  def call(arr, func, options); end
  def delete!(arr, removed_func); end
  def replace!(arr, old_func, new_func); end
end
module Representable::Cached
  def representable_map(*arg0); end
  def self.included(includer); end
end
module Representable::Cached::BuildDefinition
  def build_definition(*arg0); end
end
module Representable::ForCollection
  def collection_representer!(options); end
  def collection_representer(options = nil); end
  def for_collection; end
end
module Representable::Represent
  def represent(represented, array_class = nil); end
end
module Representable::ModuleExtensions
  def extended(object); end
end
module Representable::ClassMethods
  def prepare(represented); end
end
module Representable::Hash
  def filter_wrap(data, options); end
  def filter_wrap_for(data, wrap); end
  def from_hash(data, options = nil, binding_builder = nil); end
  def parse(data, options = nil, binding_builder = nil); end
  def render(options = nil, binding_builder = nil); end
  def self.included(base); end
  def to_hash(options = nil, binding_builder = nil); end
end
class Representable::Hash::Binding < Representable::Binding
  def deserialize_method; end
  def read(hash, as); end
  def self.build_for(definition); end
  def serialize_method; end
  def write(hash, fragment, as); end
end
class Representable::Hash::Binding::Collection < Representable::Hash::Binding
  include Representable::Binding::Collection
end
module Representable::Hash::ClassMethods
  def collection_representer_class; end
  def format_engine; end
end
module Representable::JSON
  def from_json(data, *args); end
  def parse(data, *args); end
  def render(*args); end
  def self.included(base); end
  def to_json(*args); end
  extend Representable::ClassMethods
  extend Representable::Declarative
  extend Representable::ForCollection
  extend Representable::Hash::ClassMethods
  extend Representable::Hash::ClassMethods
  extend Representable::ModuleExtensions
  extend Representable::Represent
  include Representable
  include Representable::Hash
end
module Representable::JSON::ClassMethods
  def collection_representer_class; end
  def format_engine; end
end

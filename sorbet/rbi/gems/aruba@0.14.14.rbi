# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aruba` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Aruba
  class << self
    def config; end
    def configure(&block); end
    def platform; end
    def process; end
    def process=(_arg0); end
  end
end

module Aruba::Api
  include ::Aruba::Api::Text
  include ::Aruba::Api::Core
  include ::Aruba::Api::Commands
  include ::Aruba::Api::Environment
  include ::Aruba::Api::Filesystem
  include ::Aruba::Api::Bundler
  include ::Aruba::Api::Deprecated
  include ::RSpec::Matchers
end

module Aruba::Api::Bundler
  include ::Aruba::Api::Environment

  def unset_bundler_env_vars; end
end

module Aruba::Api::Commands
  def all_commands; end
  def all_output; end
  def all_stderr; end
  def all_stdout; end
  def close_input; end
  def find_command(commandline); end
  def last_command_started; end
  def last_command_stopped; end
  def pipe_in_file(file_name); end
  def run_command(*args); end
  def run_command_and_stop(*args); end
  def stop_all_commands(&block); end
  def terminate_all_commands(&block); end
  def type(input); end
  def which(program, path = T.unsafe(nil)); end
end

module Aruba::Api::Core
  include ::RSpec::Matchers

  def aruba; end
  def cd(dir, &block); end
  def expand_path(file_name, dir_string = T.unsafe(nil)); end
  def in_current_directory(&block); end
  def setup_aruba(clobber = T.unsafe(nil)); end
  def with_environment(env = T.unsafe(nil), &block); end
end

module Aruba::Api::Deprecated
  def _create_file(name, content, check_presence); end
  def _create_fixed_size_file(file_name, file_size, check_presence); end
  def _ensure_newline(str); end
  def _mkdir(dir_name); end
  def _read_interactive; end
  def _rm(dir_name); end
  def _write_interactive(input); end
  def absolute_path(*args); end
  def announce_or_puts(msg); end
  def announcer; end
  def append_output_to(message); end
  def assert_exact_output(expected, actual); end
  def assert_exit_status(status); end
  def assert_exit_status_and_output(expect_to_pass, expected_output, expect_exact_output); end
  def assert_exit_status_and_partial_output(expect_to_pass, expected); end
  def assert_failing_with(expected); end
  def assert_matching_output(expected, actual); end
  def assert_no_partial_output(unexpected, actual); end
  def assert_not_exit_status(status); end
  def assert_not_matching_output(expected, actual); end
  def assert_partial_output(expected, actual); end
  def assert_partial_output_interactive(expected); end
  def assert_passing_with(expected); end
  def assert_success(success); end
  def check_binary_file_content(file, reference_file, expect_match = T.unsafe(nil)); end
  def check_directory_presence(paths, expect_presence); end
  def check_exact_file_content(file, exact_content, expect_match = T.unsafe(nil)); end
  def check_file_content(file, content, expect_match = T.unsafe(nil)); end
  def check_file_presence(paths, expect_presence = T.unsafe(nil)); end
  def check_file_size(paths_and_sizes); end
  def check_filesystem_permissions(*args); end
  def check_for_deprecated_variables; end
  def clean_current_dir(*args, &block); end
  def clean_current_directory; end
  def create_dir(*args); end
  def current_dir(*args, &block); end
  def current_directory; end
  def current_ruby; end
  def detect_ruby(cmd); end
  def dirs; end
  def eot; end
  def exit_timeout; end
  def filesystem_permissions(*args); end
  def fixtures_directory; end
  def get_process(wanted); end
  def in_current_dir(&block); end
  def io_wait; end
  def last_command; end
  def last_exit_status; end
  def mod?(file, perms, &block); end
  def only_processes; end
  def original_env; end
  def output_from(cmd); end
  def prep_for_fs_check(&block); end
  def process_monitor; end
  def processes; end
  def register_process(*args); end
  def remove_dir(*args); end
  def remove_directory(*args); end
  def remove_file(*args); end
  def restore_env; end
  def root_directory; end
  def run(*args); end
  def run_interactive(cmd); end
  def run_simple(*args); end
  def set_env(key, value); end
  def stderr_from(cmd); end
  def stdout_from(cmd); end
  def stop_process(process); end
  def stop_processes!; end
  def terminate_process(process); end
  def terminate_processes!; end
  def touch_file(*args); end
  def unescape(string, keep_ansi = T.unsafe(nil)); end
  def use_clean_gemset(gemset); end
  def with_env(env = T.unsafe(nil), &block); end
end

module Aruba::Api::Environment
  def append_environment_variable(name, value); end
  def delete_environment_variable(name); end
  def prepend_environment_variable(name, value); end
  def set_environment_variable(name, value); end
end

module Aruba::Api::Filesystem
  def absolute?(path); end
  def all_directories; end
  def all_files; end
  def all_paths; end
  def append_to_file(file_name, file_content); end
  def chmod(*args); end
  def copy(*args); end
  def create_directory(directory_name); end
  def directory(path); end
  def directory?(file); end
  def disk_usage(*paths); end
  def executable?(path); end
  def exist?(file_or_directory); end
  def file?(file); end
  def file_size(name); end
  def list(name); end
  def move(*args); end
  def overwrite_file(name, content); end
  def read(name); end
  def relative?(path); end
  def remove(*args); end
  def touch(*args); end
  def with_file_content(file, &block); end
  def write_file(name, content); end
  def write_fixed_size_file(name, size); end
end

module Aruba::Api::Text
  def extract_text(text); end
  def replace_variables(text); end
  def sanitize_text(text); end
  def unescape_text(text); end
end

class Aruba::ArubaLogger
  def initialize(opts = T.unsafe(nil)); end

  def debug(msg); end
  def error(msg); end
  def fatal(msg); end
  def info(msg); end
  def logger; end
  def mode; end
  def mode=(m); end
  def mode?(m); end
  def unknown(msg); end
  def warn(msg); end

  private

  def format_debug(l); end
  def format_standard(l); end
end

class Aruba::ArubaPath
  def initialize(path); end

  def <<(p); end
  def [](index); end
  def __getobj__; end
  def __setobj__(obj); end
  def blocks; end
  def depth; end
  def end_with?(string); end
  def pop; end
  def push(p); end
  def start_with?(string); end
end

class Aruba::BasicConfiguration
  extend ::Contracts::Core
  include ::Contracts::Builtin
  include ::Contracts
  include ::Contracts::Core
  extend ::Contracts::MethodDecorators
  extend ::Contracts::Attrs
  extend ::Contracts::Builtin
  extend ::Contracts
  include ::Contracts::Attrs

  def initialize; end

  def ==(other); end
  def Contract(*args); end
  def after(name, context = T.unsafe(nil), *args, &block); end
  def after?(name); end
  def before(name, context = T.unsafe(nil), *args, &block); end
  def before?(name); end
  def before_cmd(&block); end
  def configure; end
  def functype(funcname); end
  def hooks; end
  def make_copy; end
  def option?(name); end
  def reset; end
  def set_if_option(name, *args); end

  protected

  def hooks=(_arg0); end
  def local_options; end
  def local_options=(_arg0); end

  private

  def find_option(name); end
  def initialize_configuration; end

  class << self
    def Contract(*args); end
    def __contracts_engine; end
    def functype(funcname); end
    def known_options; end
    def option_accessor(name, opts = T.unsafe(nil)); end
    def option_reader(name, opts = T.unsafe(nil)); end

    private

    def add_option(name, value = T.unsafe(nil)); end
  end
end

class Aruba::BasicConfiguration::Option
  def initialize(opts = T.unsafe(nil)); end

  def ==(other); end
  def default_value; end
  def name; end
  def name=(_arg0); end
  def value; end
  def value=(_arg0); end
end

class Aruba::Colorizer
  def cyan(string); end

  class << self
    def coloring; end
    def coloring=(_arg0); end
    def coloring?; end
  end
end

class Aruba::Command < ::SimpleDelegator
  def initialize(command, opts = T.unsafe(nil)); end

  def run!; end
  def start; end
  def stop(*_arg0); end
  def terminate(*_arg0); end

  private

  def event_bus; end
end

class Aruba::CommandAlreadyStartedError < ::Aruba::Error; end
class Aruba::CommandAlreadyStoppedError < ::Aruba::Error; end

class Aruba::CommandMonitor
  def initialize(opts = T.unsafe(nil)); end

  def all_output; end
  def all_stderr; end
  def all_stdout; end
  def clear; end
  def find(cmd); end
  def get_process(wanted); end
  def last_command_started; end
  def last_command_started=(cmd); end
  def last_command_stopped; end
  def last_command_stopped=(cmd); end
  def last_exit_status; end
  def only_processes; end
  def output_from(cmd); end
  def register_command(cmd); end
  def registered_commands; end
  def stderr_from(cmd); end
  def stdout_from(cmd); end
  def stop_process(process); end
  def stop_processes!; end
  def terminate_process!(process); end
  def terminate_processes; end

  private

  def announcer; end
end

class Aruba::CommandMonitor::DefaultLastCommandStarted
  def method_missing(*_arg0); end
  def nil?; end
end

class Aruba::CommandMonitor::DefaultLastCommandStopped
  def method_missing(*_arg0); end
  def nil?; end
end

class Aruba::CommandNotFoundError < ::ArgumentError; end

class Aruba::Config < ::Aruba::Configuration
  def initialize(*args); end
end

class Aruba::ConfigWrapper
  def initialize(config, event_bus); end

  def ==(other); end
  def method_missing(name, *args, &block); end
  def respond_to?(m); end

  private

  def config; end
  def event_bus; end
  def respond_to_missing?(name, _include_private); end
end

class Aruba::Configuration < ::Aruba::BasicConfiguration
  def __contracts_ruby_original_activate_announcer_on_command_failure_kp9gmfura62p; end
  def __contracts_ruby_original_command_launcher_kp9gmfuq9w27; end
  def __contracts_ruby_original_command_runtime_environment_kp9gmfupbwll; end
  def __contracts_ruby_original_command_search_paths_kp9gmfupbwv3; end
  def __contracts_ruby_original_console_history_file_kp9gmfur5wgm; end
  def __contracts_ruby_original_exit_timeout_kp9gmfuojcbp; end
  def __contracts_ruby_original_fixtures_directories_kp9gmfup7vx9; end
  def __contracts_ruby_original_fixtures_path_prefix_kp9gmfuo9tm6; end
  def __contracts_ruby_original_home_directory_kp9gmfuq9d7j; end
  def __contracts_ruby_original_io_wait_timeout_kp9gmfupgjbi; end
  def __contracts_ruby_original_keep_ansi_kp9gmfupa2m5; end
  def __contracts_ruby_original_log_level_kp9gmfuq2tjt; end
  def __contracts_ruby_original_main_class_kp9gmfuq1law; end
  def __contracts_ruby_original_physical_block_size_kp9gmfuqcwwp; end
  def __contracts_ruby_original_remove_ansi_escape_sequences_kp9gmfuqbyie; end
  def __contracts_ruby_original_root_directory_kp9gmfuok32b; end
  def __contracts_ruby_original_startup_wait_time_kp9gmfupd84z; end
  def __contracts_ruby_original_stop_signal_kp9gmfuo1ufw; end
  def __contracts_ruby_original_working_directory_kp9gmfuodvqe; end
  def activate_announcer_on_command_failure(*args, &blk); end
  def activate_announcer_on_command_failure=(*args, &blk); end
  def command_launcher(*args, &blk); end
  def command_launcher=(*args, &blk); end
  def command_runtime_environment(*args, &blk); end
  def command_runtime_environment=(*args, &blk); end
  def command_search_paths(*args, &blk); end
  def command_search_paths=(*args, &blk); end
  def console_history_file(*args, &blk); end
  def console_history_file=(*args, &blk); end
  def exit_timeout(*args, &blk); end
  def exit_timeout=(*args, &blk); end
  def fixtures_directories(*args, &blk); end
  def fixtures_directories=(*args, &blk); end
  def fixtures_path_prefix(*args, &blk); end
  def home_directory(*args, &blk); end
  def home_directory=(*args, &blk); end
  def io_wait_timeout(*args, &blk); end
  def io_wait_timeout=(*args, &blk); end
  def keep_ansi(*args, &blk); end
  def keep_ansi=(*args, &blk); end
  def log_level(*args, &blk); end
  def log_level=(*args, &blk); end
  def main_class(*args, &blk); end
  def main_class=(*args, &blk); end
  def physical_block_size(*args, &blk); end
  def physical_block_size=(*args, &blk); end
  def remove_ansi_escape_sequences(*args, &blk); end
  def remove_ansi_escape_sequences=(*args, &blk); end
  def root_directory(*args, &blk); end
  def root_directory=(*args, &blk); end
  def startup_wait_time(*args, &blk); end
  def startup_wait_time=(*args, &blk); end
  def stop_signal(*args, &blk); end
  def stop_signal=(*args, &blk); end
  def working_directory(*args, &blk); end
  def working_directory=(*args, &blk); end
end

module Aruba::Contracts; end

class Aruba::Contracts::AbsolutePath
  class << self
    def valid?(value); end
  end
end

class Aruba::Contracts::Enum < ::Contracts::Builtin::CallableClass
  def initialize(*vals); end

  def valid?(val); end

  private

  def vals; end
end

class Aruba::Contracts::IsPowerOfTwo
  class << self
    def valid?(value); end
  end
end

class Aruba::Contracts::RelativePath
  class << self
    def valid?(value); end
  end
end

class Aruba::Error < ::StandardError; end

class Aruba::EventBus
  def initialize(resolver); end

  def notify(event); end
  def register(event_ids, handler_object = T.unsafe(nil), &handler_proc); end
end

class Aruba::EventBus::NameResolver
  def initialize(default_namespace); end

  def transform(event_id); end

  protected

  def default_namespace; end
  def resolvers; end
end

class Aruba::EventBus::NameResolver::ClassResolver
  def transform(_, event_id); end

  class << self
    def match?(event_id); end
    def supports; end
  end
end

class Aruba::EventBus::NameResolver::FailingResolver
  class << self
    def match?(event_id); end
    def supports; end
  end
end

module Aruba::EventBus::NameResolver::ResolveHelpers
  def camel_case(underscored_name); end
  def constantize(camel_cased_word); end
end

class Aruba::EventBus::NameResolver::StringResolver
  include ::Aruba::EventBus::NameResolver::ResolveHelpers

  def transform(_, event_id); end

  class << self
    def match?(event_id); end
    def supports; end
  end
end

class Aruba::EventBus::NameResolver::SymbolResolver
  include ::Aruba::EventBus::NameResolver::ResolveHelpers

  def transform(default_namespace, event_id); end

  class << self
    def match?(event_id); end
    def supports; end
  end
end

class Aruba::EventNameResolveError < ::StandardError; end
module Aruba::Events; end
class Aruba::Events::AddedEnvironmentVariable < ::Aruba::Events::BasicEvent; end

class Aruba::Events::BasicEvent
  def initialize(entity); end

  def entity; end
end

class Aruba::Events::ChangedConfiguration < ::Aruba::Events::BasicEvent; end
class Aruba::Events::ChangedEnvironmentVariable < ::Aruba::Events::BasicEvent; end
class Aruba::Events::ChangedWorkingDirectory < ::Aruba::Events::BasicEvent; end
class Aruba::Events::CommandStarted < ::Aruba::Events::BasicEvent; end
class Aruba::Events::CommandStopped < ::Aruba::Events::BasicEvent; end
class Aruba::Events::DeletedEnvironmentVariable < ::Aruba::Events::BasicEvent; end

class Aruba::FileSize
  include ::Comparable

  def initialize(bytes); end

  def <=>(other); end
  def coerce(other); end
  def inspect; end
  def to_byte; end
  def to_f; end
  def to_gibi_byte; end
  def to_i; end
  def to_kibi_byte; end
  def to_mebi_byte; end
  def to_s; end

  private

  def bytes; end
  def divisor; end
end

class Aruba::Hooks
  def initialize; end

  def append(label, block); end
  def execute(label, context, *args); end
  def exist?(label); end

  private

  def store; end
end

class Aruba::InConfigWrapper
  def initialize(config); end

  def method_missing(name, *args); end

  private

  def config; end
end

class Aruba::LaunchError < ::Aruba::Error; end

module Aruba::Matchers
  include ::RSpec::Matchers

  class << self
    def all(expected); end
  end
end

class Aruba::Matchers::BaseMatcher
  include ::Aruba::Matchers::BaseMatcher::HashFormatting
  include ::Aruba::Matchers::BaseMatcher::DefaultFailureMessages

  def initialize(expected = T.unsafe(nil)); end

  def actual; end
  def description_of(object); end
  def expected; end
  def iterable?; end
  def matches?(actual); end
  def rescued_exception; end
end

module Aruba::Matchers::BaseMatcher::DefaultFailureMessages
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    def has_default_failure_messages?(matcher); end
  end
end

module Aruba::Matchers::BaseMatcher::HashFormatting
  private

  def improve_hash_formatting(inspect_string); end

  class << self
    def improve_hash_formatting(inspect_string); end
  end
end

Aruba::Matchers::BaseMatcher::UNDEFINED = T.let(T.unsafe(nil), Object)

class Aruba::Matchers::IncludeAnObject < ::Aruba::Matchers::BaseMatcher
  def initialize(matcher); end

  def description; end
  def does_not_match?(actual); end
  def failure_message; end

  protected

  def any_succeeded_object; end
  def any_succeeded_object=(_arg0); end
  def failed_objects; end
  def matcher; end

  private

  def add_new_line_if_needed(message); end
  def failure_message_for_item(index, failure_message); end
  def indent_multiline_message(message); end
  def index_objects; end
  def match(expected, actual); end
end

module Aruba::Matchers::ObjectFormatter
  class << self
    def format(object); end
    def format_date_time(date_time); end
    def format_time(time); end
    def prepare_for_inspection(object); end
    def prepare_hash(input); end
  end
end

Aruba::Matchers::ObjectFormatter::DATE_TIME_FORMAT = T.let(T.unsafe(nil), String)

class Aruba::Matchers::ObjectFormatter::DelegatingInspector < ::Struct
  def inspect; end
  def object; end
  def object=(_); end
  def pretty_print(pp); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Aruba::Matchers::ObjectFormatter::InspectableItem < ::Struct
  def inspect; end
  def inspection; end
  def inspection=(_); end
  def pretty_print(pp); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Aruba::Matchers::ObjectFormatter::TIME_FORMAT = T.let(T.unsafe(nil), String)
class Aruba::NoCommandHasBeenStartedError < ::Aruba::Error; end
class Aruba::NoCommandHasBeenStoppedError < ::Aruba::Error; end
class Aruba::NoEventError < ::StandardError; end
Aruba::PLATFORM_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
Aruba::Platform = Aruba::Platforms::UnixPlatform
module Aruba::Platforms; end

class Aruba::Platforms::Announcer
  def initialize(*args); end

  def activate(*chns); end
  def activated?(channel); end
  def announce(channel, *args, &block); end
  def cmd(cmd); end
  def dir(dir); end
  def env(name, value); end
  def mode=(m); end
  def reset; end
  def stderr(content); end
  def stdout(content); end

  private

  def after_init; end
  def announcer; end
  def announcers; end
  def channels; end
  def colorizer; end
  def output_format(channel, string = T.unsafe(nil), &block); end
  def output_formats; end
end

class Aruba::Platforms::Announcer::KernelPutsAnnouncer
  def announce(message); end
  def mode?(m); end
end

class Aruba::Platforms::Announcer::PutsAnnouncer
  def announce(message); end
  def mode?(m); end
end

class Aruba::Platforms::ArubaFileCreator
  def call(path, content, check_presence = T.unsafe(nil)); end
end

class Aruba::Platforms::ArubaFixedSizeFileCreator
  def call(path, size, check_presence); end
end

class Aruba::Platforms::DetermineDiskUsage
  def call(*args); end
end

class Aruba::Platforms::DetermineFileSize
  def call(path); end
end

class Aruba::Platforms::DiskUsageCalculator
  def call(blocks, block_size); end
end

class Aruba::Platforms::FilesystemStatus
  extend ::Forwardable

  def initialize(path); end

  def atime(*args, &block); end
  def ctime(*args, &block); end
  def executable?(*args, &block); end
  def group; end
  def mode; end
  def mtime(*args, &block); end
  def owner; end
  def size(*args, &block); end
  def to_h; end

  private

  def status; end
end

Aruba::Platforms::FilesystemStatus::METHODS = T.let(T.unsafe(nil), Array)

class Aruba::Platforms::LocalEnvironment
  def call(env, &block); end
end

class Aruba::Platforms::SimpleTable
  def initialize(hash, opts); end

  def to_s; end

  private

  def hash; end
  def opts; end
end

class Aruba::Platforms::UnixCommandString < ::SimpleDelegator
  def initialize(cmd); end

  def to_a; end
end

class Aruba::Platforms::UnixEnvironmentVariables
  def initialize(env = T.unsafe(nil)); end

  def [](name); end
  def []=(name, value); end
  def append(name, value); end
  def clear; end
  def delete(name); end
  def fetch(name, default = T.unsafe(nil)); end
  def key?(name); end
  def method_missing(name, *args, &block); end
  def prepend(name, value); end
  def to_h; end
  def update(other_env); end

  private

  def actions; end
  def env; end
  def prepared_environment; end
  def respond_to_missing?(name, _private); end
end

class Aruba::Platforms::UnixEnvironmentVariables::RemoveAction
  def initialize(variables); end

  def call(env); end
  def variables; end
end

Aruba::Platforms::UnixEnvironmentVariables::UNDEFINED = T.let(T.unsafe(nil), Object)

class Aruba::Platforms::UnixEnvironmentVariables::UpdateAction
  def initialize(other_env, &block); end

  def block; end
  def call(env); end
  def other_env; end
end

class Aruba::Platforms::UnixPlatform
  def absolute_path?(path); end
  def announcer; end
  def chdir(dir_name, &block); end
  def chmod(mode, args, options); end
  def command?(path); end
  def command_monitor; end
  def command_string; end
  def cp(src, dest); end
  def create_file(*args); end
  def create_fixed_size_file(*args); end
  def current_ruby; end
  def default_shell; end
  def deprecated(msg); end
  def detect_ruby(cmd); end
  def determine_disk_usage(*args); end
  def determine_file_size(*args); end
  def directory?(f); end
  def ensure_newline(str); end
  def environment_variables; end
  def executable?(f); end
  def exist?(f); end
  def expand_path(path, base); end
  def file?(f); end
  def filesystem_status; end
  def getwd; end
  def logger; end
  def mkdir(dir_name); end
  def mv(src, dest); end
  def relative_command?(path); end
  def relative_path?(path); end
  def require_matching_files(pattern, base); end
  def rm(paths, options = T.unsafe(nil)); end
  def simple_table(hash, opts = T.unsafe(nil)); end
  def touch(args, options); end
  def unescape(string, keep_ansi = T.unsafe(nil)); end
  def which(program, path = T.unsafe(nil)); end
  def with_environment(env = T.unsafe(nil), &block); end
  def write_file(path, content); end

  class << self
    def match?; end
  end
end

class Aruba::Platforms::UnixWhich
  def initialize; end

  def call(program, path = T.unsafe(nil)); end

  private

  def whiches; end
end

class Aruba::Platforms::UnixWhich::AbsoluteOrRelativePathWhich
  def call(program, path); end

  class << self
    def match?(program); end
  end
end

class Aruba::Platforms::UnixWhich::DefaultWhich
  def call(program, path); end

  class << self
    def match?(*_arg0); end
  end
end

class Aruba::Platforms::UnixWhich::ProgramWhich
  def call(program, path); end

  class << self
    def match?(program); end
  end
end

class Aruba::Platforms::WindowsCommandString < ::SimpleDelegator
  def to_a; end

  private

  def cmd_path; end
end

class Aruba::Platforms::WindowsEnvironmentVariables < ::Aruba::Platforms::UnixEnvironmentVariables
  def initialize(env = T.unsafe(nil)); end

  def [](name); end
  def []=(name, value); end
  def append(name, value); end
  def delete(name, value); end
  def fetch(name, default = T.unsafe(nil)); end
  def key?(name); end
  def prepend(name, value); end
  def update(other_env, &block); end
end

class Aruba::Platforms::WindowsPlatform < ::Aruba::Platforms::UnixPlatform
  def command_string; end
  def environment_variables; end
  def which(program, path = T.unsafe(nil)); end

  class << self
    def match?; end
  end
end

class Aruba::Platforms::WindowsWhich
  def initialize; end

  def call(program, path = T.unsafe(nil)); end

  private

  def whiches; end
  def windows_executable_extentions; end
end

class Aruba::Platforms::WindowsWhich::AbsoluteOrRelativePathWhich
  def call(program, path); end

  class << self
    def match?(program); end
  end
end

class Aruba::Platforms::WindowsWhich::DefaultWhich
  def call(program, path); end

  class << self
    def match?(*_arg0); end
  end
end

class Aruba::Platforms::WindowsWhich::ProgramWhich
  def call(program, path); end

  class << self
    def match?(program); end
  end
end

module Aruba::Processes; end

class Aruba::Processes::BasicProcess
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = T.unsafe(nil), main_class = T.unsafe(nil), stop_signal = T.unsafe(nil), startup_wait_time = T.unsafe(nil)); end

  def after_run; end
  def before_run; end
  def close_io(*_arg0); end
  def commandline; end
  def content; end
  def environment; end
  def exit_status; end
  def exit_timeout; end
  def filesystem_status; end
  def inspect; end
  def io_wait_timeout; end
  def main_class; end
  def output(opts = T.unsafe(nil)); end
  def pid; end
  def restart; end
  def run!; end
  def send_signal(*_arg0); end
  def started?; end
  def startup_wait_time; end
  def stderr(*_arg0); end
  def stdin(*_arg0); end
  def stdout(*_arg0); end
  def stopped?; end
  def timed_out?; end
  def to_s; end
  def wait; end
  def working_directory; end
  def write(*_arg0); end

  private

  def arguments; end
  def command; end
end

class Aruba::Processes::DebugProcess < ::Aruba::Processes::BasicProcess
  def close_io(*_arg0); end
  def start; end
  def stderr(*_arg0); end
  def stdin(*_arg0); end
  def stdout(*_arg0); end
  def stop(*_arg0); end
  def terminate(*_arg0); end
  def write(*_arg0); end

  class << self
    def match?(mode); end
  end
end

class Aruba::Processes::InProcess < ::Aruba::Processes::BasicProcess
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = T.unsafe(nil), main_class = T.unsafe(nil), stop_signal = T.unsafe(nil), startup_wait_time = T.unsafe(nil)); end

  def close_io(name); end
  def exit_status; end
  def main_class; end
  def pid; end
  def start; end
  def stderr(*_arg0); end
  def stdin; end
  def stdout(*_arg0); end
  def stop(*_arg0); end
  def terminate; end
  def write(input); end

  class << self
    def main_class; end
    def main_class=(_arg0); end
    def match?(mode); end
  end
end

class Aruba::Processes::InProcess::FakeKernel
  def initialize; end

  def exit(exitstatus); end
  def exitstatus; end
end

class Aruba::Processes::SpawnProcess < ::Aruba::Processes::BasicProcess
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = T.unsafe(nil), main_class = T.unsafe(nil), stop_signal = T.unsafe(nil), startup_wait_time = T.unsafe(nil)); end

  def close_io(name); end
  def content; end
  def filesystem_status; end
  def pid; end
  def read_stdout; end
  def send_signal(signal); end
  def start; end
  def stderr(opts = T.unsafe(nil)); end
  def stdin; end
  def stdout(opts = T.unsafe(nil)); end
  def stop(*_arg0); end
  def terminate; end
  def wait; end
  def write(input); end

  private

  def command_string; end
  def read_temporary_output_file(file); end
  def wait_for_io(time_to_wait, &block); end

  class << self
    def match?(mode); end
  end
end

class Aruba::Runtime
  def initialize(opts = T.unsafe(nil)); end

  def announcer; end
  def announcer=(_arg0); end
  def command_monitor; end
  def command_monitor=(_arg0); end
  def config; end
  def config=(_arg0); end
  def current_directory; end
  def environment; end
  def environment=(_arg0); end
  def event_bus; end
  def event_bus=(_arg0); end
  def fixtures_directory; end
  def logger; end
  def logger=(_arg0); end
  def root_directory; end
  def setup_already_done?; end
  def setup_done; end
end

class Aruba::Setup
  def initialize(runtime); end

  def call(clobber = T.unsafe(nil)); end

  private

  def events; end
  def runtime; end
  def working_directory(clobber = T.unsafe(nil)); end
end

class Aruba::UnknownOptionError < ::ArgumentError; end
class Aruba::UserError < ::StandardError; end
Aruba::VERSION = T.let(T.unsafe(nil), String)

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    def clear_examples; end
    def configuration; end
    def configuration=(_arg0); end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def world; end
    def world=(_arg0); end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL

  def a_block_changing(*args, &block); end
  def a_block_outputting(*args, &block); end
  def a_block_raising(*args, &block); end
  def a_block_throwing(*args, &block); end
  def a_block_yielding_control(*args, &block); end
  def a_block_yielding_successive_args(*args, &block); end
  def a_block_yielding_with_args(*args, &block); end
  def a_block_yielding_with_no_args(*args, &block); end
  def a_collection_containing_exactly(*args, &block); end
  def a_collection_ending_with(*args, &block); end
  def a_collection_including(*args, &block); end
  def a_collection_starting_with(*args, &block); end
  def a_command_found_in_path(*args, &block); end
  def a_command_having_output(*args, &block); end
  def a_directory_having_sub_directory(*args, &block); end
  def a_falsey_value(*args, &block); end
  def a_falsy_value(*args, &block); end
  def a_file_having_content(*args, &block); end
  def a_file_name_matching(*args, &block); end
  def a_file_of_size(*args, &block); end
  def a_file_with_same_content_as(*args, &block); end
  def a_file_with_same_content_like(expected); end
  def a_hash_including(*args, &block); end
  def a_kind_of(*args, &block); end
  def a_nil_value(*args, &block); end
  def a_path_having_permissions(*args, &block); end
  def a_path_matching_pattern(*args, &block); end
  def a_range_covering(*args, &block); end
  def a_string_ending_with(*args, &block); end
  def a_string_including(*args, &block); end
  def a_string_matching(*args, &block); end
  def a_string_starting_with(*args, &block); end
  def a_truthy_value(*args, &block); end
  def a_value(*args, &block); end
  def a_value_between(*args, &block); end
  def a_value_within(*args, &block); end
  def aggregate_failures(label = T.unsafe(nil), metadata = T.unsafe(nil), &block); end
  def all(expected); end
  def an_absolute_path(*args, &block); end
  def an_existing_directory(*args, &block); end
  def an_existing_executable(*args, &block); end
  def an_existing_file(*args, &block); end
  def an_existing_path(*args, &block); end
  def an_instance_of(*args, &block); end
  def an_object_eq_to(*args, &block); end
  def an_object_eql_to(*args, &block); end
  def an_object_equal_to(*args, &block); end
  def an_object_existing(*args, &block); end
  def an_object_having_attributes(*args, &block); end
  def an_object_matching(*args, &block); end
  def an_object_responding_to(*args, &block); end
  def an_object_satisfying(*args, &block); end
  def an_output_string_being_eq(*args, &block); end
  def an_output_string_including(*args, &block); end
  def an_output_string_matching(*args, &block); end
  def be(*args); end
  def be_a(klass); end
  def be_a_command_found_in_path(*expected, &block_arg); end
  def be_a_kind_of(expected); end
  def be_an(klass); end
  def be_an_absolute_path(*expected, &block_arg); end
  def be_an_existing_directory(*expected, &block_arg); end
  def be_an_existing_executable(*expected, &block_arg); end
  def be_an_existing_file(*expected, &block_arg); end
  def be_an_existing_path(*expected, &block_arg); end
  def be_an_instance_of(expected); end
  def be_between(min, max); end
  def be_falsey; end
  def be_falsy(*args, &block); end
  def be_instance_of(expected); end
  def be_kind_of(expected); end
  def be_nil; end
  def be_successfully_executed(*expected, &block_arg); end
  def be_truthy; end
  def be_within(delta); end
  def change(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def changing(*args, &block); end
  def contain_exactly(*items); end
  def containing_exactly(*args, &block); end
  def cover(*values); end
  def covering(*args, &block); end
  def end_with(*expected); end
  def ending_with(*args, &block); end
  def eq(expected); end
  def eq_to(*args, &block); end
  def eql(expected); end
  def eql_to(*args, &block); end
  def equal(expected); end
  def equal_to(*args, &block); end
  def exist(*args); end
  def existing(*args, &block); end
  def expect(value = T.unsafe(nil), &block); end
  def file_content_including(*args, &block); end
  def file_content_matching(*args, &block); end
  def have_attributes(expected); end
  def have_exit_status(*expected, &block_arg); end
  def have_failed_running(*args, &block); end
  def have_file_content(*expected, &block_arg); end
  def have_file_size(*expected, &block_arg); end
  def have_finished_in_time(*expected, &block_arg); end
  def have_output(*expected, &block_arg); end
  def have_output_on_stderr(*expected, &block_arg); end
  def have_output_on_stdout(*expected, &block_arg); end
  def have_output_size(*expected, &block_arg); end
  def have_permissions(*expected, &block_arg); end
  def have_same_file_content_as(*expected, &block_arg); end
  def have_same_file_content_like(expected); end
  def have_sub_directory(*expected, &block_arg); end
  def having_attributes(*args, &block); end
  def include(*expected); end
  def include_an_object(expected); end
  def include_output_string(*expected, &block_arg); end
  def include_regexp(*expected, &block_arg); end
  def including(*args, &block); end
  def match(expected); end
  def match_array(items); end
  def match_output_string(*expected, &block_arg); end
  def match_path_pattern(*expected, &block_arg); end
  def match_regex(*args, &block); end
  def matching(*args, &block); end
  def output(expected = T.unsafe(nil)); end
  def output_string_eq(*expected, &block_arg); end
  def raise_error(error = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def raise_exception(error = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def raising(*args, &block); end
  def respond_to(*names); end
  def responding_to(*args, &block); end
  def run_too_long(*args, &block); end
  def satisfy(description = T.unsafe(nil), &block); end
  def satisfying(*args, &block); end
  def start_with(*expected); end
  def starting_with(*args, &block); end
  def throw_symbol(expected_symbol = T.unsafe(nil), expected_arg = T.unsafe(nil)); end
  def throwing(*args, &block); end
  def within(*args, &block); end
  def yield_control; end
  def yield_successive_args(*args); end
  def yield_with_args(*args); end
  def yield_with_no_args; end
  def yielding_control(*args, &block); end
  def yielding_successive_args(*args, &block); end
  def yielding_with_args(*args, &block); end
  def yielding_with_no_args(*args, &block); end

  private

  def method_missing(method, *args, &block); end
  def respond_to_missing?(method, *_arg1); end

  class << self
    def alias_matcher(*args, &block); end
    def clear_generated_description; end
    def configuration; end
    def generated_description; end
    def is_a_describable_matcher?(obj); end
    def is_a_matcher?(obj); end
    def last_description; end
    def last_expectation_handler; end
    def last_expectation_handler=(_arg0); end
    def last_matcher; end
    def last_matcher=(_arg0); end
  end
end

RSpec::Matchers::BE_PREDICATE_REGEX = T.let(T.unsafe(nil), Regexp)
RSpec::Matchers::DYNAMIC_MATCHER_REGEX = T.let(T.unsafe(nil), Regexp)
RSpec::Matchers::HAS_REGEX = T.let(T.unsafe(nil), Regexp)
RSpec::SharedContext = RSpec::Core::SharedContext

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colorize::InstanceMethods
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::Colorize::ClassMethods

  def strip_heredoc; end
end

# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/pastel/all/pastel.rbi
#
# pastel-0.6.1

module Pastel
  def new(options = nil); end
  def self.new(options = nil); end
end
module Pastel::ANSI
  def background?(code); end
  def foreground?(code); end
  def self.background?(code); end
  def self.foreground?(code); end
  def self.style?(code); end
  def style?(code); end
end
class Pastel::AliasImporter
  def color; end
  def env; end
  def import; end
  def initialize(color, env, output = nil); end
  def output; end
end
class Pastel::Color
  def alias_color(alias_name, color); end
  def apply_codes(string, ansi_colors); end
  def blank?(value); end
  def clear; end
  def code(*colors); end
  def colored?(string); end
  def compare?(comparator, other); end
  def decorate(string, *colors); end
  def disable!; end
  def eachline; end
  def enabled; end
  def enabled?; end
  def hash; end
  def initialize(options = nil); end
  def inspect; end
  def lookup(*colors); end
  def strip(*strings); end
  def style_names; end
  def styles; end
  def valid?(*colors); end
  def validate(*colors); end
  extend Equatable
  include Equatable
  include Equatable::Methods
  include Pastel::ANSI
end
class Pastel::ColorParser
  def self.ansi_for(ansi); end
  def self.attribute_for(ansi); end
  def self.parse(text); end
  def self.unpack_ansi(ansi_stack); end
  include Pastel::ANSI
end
class Pastel::ColorResolver
  def color; end
  def initialize(color); end
  def resolve(base, unprocessed_string); end
end
class Pastel::Delegator
  def alias_color(*args, &block); end
  def base; end
  def colored?(*args, &block); end
  def compare?(comparator, other); end
  def decorate(*args, &block); end
  def enabled?(*args, &block); end
  def evaluate_block(&block); end
  def hash; end
  def initialize(resolver, base); end
  def inspect; end
  def lookup(*args, &block); end
  def method_missing(method_name, *args, &block); end
  def parse(*args, &block); end
  def resolver; end
  def respond_to_missing?(name, include_all = nil); end
  def self.for(resolver, base); end
  def strip(*args, &block); end
  def styles(*args, &block); end
  def to_s; end
  def undecorate(*args, &block); end
  def valid?(*args, &block); end
  def wrap(base); end
  extend Equatable
  extend Forwardable
  include Equatable
  include Equatable::Methods
end
class Pastel::Detached
  def [](*args); end
  def call(*args); end
  def compare?(comparator, other); end
  def hash; end
  def initialize(color, *styles); end
  def inspect; end
  def styles; end
  def to_proc; end
  extend Equatable
  include Equatable
  include Equatable::Methods
end
class Pastel::DecoratorChain
  def add(decorator); end
  def compare?(comparator, other); end
  def decorators; end
  def each(&block); end
  def hash; end
  def initialize(decorators = nil); end
  def inspect; end
  def self.empty; end
  extend Equatable
  include Enumerable
  include Equatable
  include Equatable::Methods
end
class Pastel::InvalidAttributeNameError < ArgumentError
end
class Pastel::InvalidAliasNameError < ArgumentError
end

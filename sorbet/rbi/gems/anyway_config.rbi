# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/anyway_config/all/anyway_config.rbi
#
# anyway_config-2.1.0

module Anyway
  def self.env; end
  def self.loaders; end
end
module Anyway::Ext
end
module Anyway::Ext::DeepDup
end
module Anyway::Ext::DeepFreeze
end
module Anyway::Ext::Hash
end
module Anyway::Utils
  def self.deep_merge!(source, other); end
end
class Anyway::Settings
  def self.default_config_path; end
  def self.default_config_path=(val); end
  def self.future; end
  def self.tracing_enabled; end
  def self.tracing_enabled=(arg0); end
  def self.use_local_files; end
  def self.use_local_files=(arg0); end
end
class Anyway::Settings::Future
  def initialize; end
  def self.setting(name, default_value); end
  def self.settings; end
  def store; end
  def use(*names); end
end
module Anyway::Tracing
  def self.accessor_source(location); end
  def self.capture; end
  def self.current_trace; end
  def self.current_trace_source; end
  def self.source_stack; end
  def self.trace!(type, *path, **opts); end
  def self.trace_stack; end
  def self.tracing?; end
  def self.with_trace_source(src); end
  def trace!(type, *path, **opts); end
end
class Anyway::Tracing::Trace
  def clear; end
  def dig(**, &&); end
  def dup; end
  def initialize(type = nil, value = nil, **source); end
  def keep_if(**, &&); end
  def merge!(another_trace); end
  def merge_values(hash, **opts); end
  def pretty_print(q); end
  def record_value(val, *path, **opts); end
  def source; end
  def to_h; end
  def trace?; end
  def type; end
  def value; end
end
class Anyway::OptionParserBuilder
  def self.call(options); end
  def self.option_parser_on_args(key, flag: nil, desc: nil, type: nil); end
end
module Anyway::OptparseConfig
  def option_parser; end
  def parse_options!(options); end
  def self.included(base); end
end
module Anyway::OptparseConfig::ClassMethods
  def describe_options(**hargs); end
  def extend_options(&block); end
  def flag_options(*args); end
  def ignore_options(*args); end
  def option_parser_descriptors; end
  def option_parser_extensions; end
  def option_parser_options; end
end
module Anyway::DynamicConfig
  def self.included(base); end
end
module Anyway::DynamicConfig::ClassMethods
  def for(name, **options); end
end
class Anyway::Config
  def __trace__; end
  def clear; end
  def config_name; end
  def deconstruct_keys(keys); end
  def dig(*keys); end
  def dup; end
  def env_prefix; end
  def initialize(overrides = nil); end
  def inspect; end
  def load(overrides = nil); end
  def load_from_sources(base_config, **options); end
  def pretty_print(q); end
  def raise_validation_error(msg); end
  def reload(overrides = nil); end
  def resolve_config_path(name, env_prefix); end
  def self.accessors_module; end
  def self.attr_config(*args, **hargs); end
  def self.build_config_name; end
  def self.config_attributes; end
  def self.config_name(val = nil); end
  def self.defaults; end
  def self.define_config_accessor(*names); end
  def self.env_prefix(val = nil); end
  def self.explicit_config_name; end
  def self.explicit_config_name?; end
  def self.load_callbacks; end
  def self.new_empty_config; end
  def self.on_load(*names, &block); end
  def self.required(*names); end
  def self.required_attributes; end
  def self.validate_param_names!(names); end
  def to_h; end
  def to_source_trace; end
  def validate_required_attributes!; end
  def values; end
  def write_config_attr(key, val); end
  extend Anyway::DynamicConfig::ClassMethods
  extend Anyway::OptparseConfig::ClassMethods
  include Anyway::DynamicConfig
  include Anyway::OptparseConfig
end
class Anyway::Config::Error < StandardError
end
class Anyway::Config::ValidationError < Anyway::Config::Error
end
class Anyway::Config::BlockCallback
  def apply_to(config); end
  def block; end
  def initialize(block); end
end
class Anyway::Config::NamedCallback
  def apply_to(config); end
  def initialize(name); end
  def name; end
end
module Anyway::AutoCast
  def self.call(val); end
end
class Anyway::Env
  def clear; end
  def data; end
  def fetch(prefix); end
  def fetch_with_trace(prefix); end
  def initialize(type_cast: nil); end
  def parse_env(prefix); end
  def traces; end
  def type_cast; end
  include Anyway::Tracing
end
module Anyway::Loaders
end
class Anyway::Loaders::Base
  def initialize(local:); end
  def self.call(local: nil, **opts); end
  def use_local?; end
  include Anyway::Tracing
end
class Anyway::Loaders::YAML < Anyway::Loaders::Base
  def call(config_path:, **_options); end
  def load_base_yml(path); end
  def load_local_yml(path); end
  def local_config_path(path); end
  def parse_yml(path); end
  def relative_config_path(path); end
end
class Anyway::Loaders::Env < Anyway::Loaders::Base
  def call(env_prefix:, **_options); end
end
class Anyway::Loaders::Registry
  def append(id, handler = nil, &block); end
  def delete(id); end
  def each(&block); end
  def find(id); end
  def freeze; end
  def initialize; end
  def insert_after(another_id, id, handler = nil, &block); end
  def insert_at(index, id, handler); end
  def insert_before(another_id, id, handler = nil, &block); end
  def override(id, handler); end
  def prepend(id, handler = nil, &block); end
  def registry; end
end
